<!DOCTYPE html>
<html lang="sr" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %> | DTrade AI</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        slate: {
                            850: '#1e293b',
                            950: '#020617'
                        }
                    }
                }
            }
        }
    </script>

    <!-- Chart.js for real-time charts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>

    <style>
        .orderbook-table {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 11px;
        }
        .price-up { color: #10b981; }
        .price-down { color: #ef4444; }
        .price-neutral { color: #94a3b8; }

        .trade-flow-item {
            transition: all 0.3s ease;
            opacity: 0;
            animation: fadeInSlide 0.5s forwards;
        }

        @keyframes fadeInSlide {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .micro-widget {
            background: linear-gradient(135deg, rgba(51, 65, 85, 0.6) 0%, rgba(30, 41, 59, 0.8) 100%);
            backdrop-filter: blur(10px);
        }
    </style>
</head>

<body class="bg-slate-950 text-slate-100 min-h-screen">

    <div class="w-full px-6 py-6 space-y-6">        <!-- Header -->
        <div class="flex items-center justify-between">
            <div>
                <h1 class="text-3xl font-bold tracking-tight">Microstructure Monitor</h1>
                <p class="text-slate-400 mt-1">FAZA 3 - Real-time market microstructure analysis</p>
                <p class="text-xs text-slate-500 mt-1">Last updated: <%= currentTime %></p>
            </div>
            <div class="flex items-center space-x-3">
                <div class="flex items-center space-x-2 text-sm">
                    <div class="w-3 h-3 rounded-full bg-green-400 animate-pulse"></div>
                    <span class="text-green-400 font-medium">Live Data</span>
                </div>
                <select id="symbol-selector" class="bg-slate-800 border border-slate-700 rounded px-3 py-1 text-sm text-slate-200">
                    <option value="">Select Symbol...</option>
                </select>
            </div>
        </div>

        <!-- Microstructure Overview Cards -->
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
            <div class="micro-widget rounded-xl border border-slate-700 p-4">
                <div class="text-xs text-slate-400 mb-1">Active Symbols</div>
                <div class="text-2xl font-bold text-slate-100" id="active-symbols-count">-</div>
                <div class="text-xs text-slate-500 mt-1" id="symbols-status">Loading...</div>
            </div>

            <div class="micro-widget rounded-xl border border-slate-700 p-4">
                <div class="text-xs text-slate-400 mb-1">Data Rate</div>
                <div class="text-2xl font-bold text-blue-400" id="data-rate">- evt/s</div>
                <div class="text-xs text-slate-500 mt-1">Events per second</div>
            </div>

            <div class="micro-widget rounded-xl border border-slate-700 p-4">
                <div class="text-xs text-slate-400 mb-1">Storage Used</div>
                <div class="text-2xl font-bold text-emerald-400" id="storage-used">- MB</div>
                <div class="text-xs text-slate-500 mt-1">Today's data</div>
            </div>

            <div class="micro-widget rounded-xl border border-slate-700 p-4">
                <div class="text-xs text-slate-400 mb-1">System Health</div>
                <div class="text-2xl font-bold text-green-400" id="system-health">Good</div>
                <div class="text-xs text-slate-500 mt-1" id="health-details">All systems operational</div>
            </div>
        </div>

        <!-- Main Content Grid -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">

            <!-- Left Column: Symbol Selection & Orderbook -->
            <div class="space-y-6">

                <!-- Symbol Stats -->
                <div class="rounded-xl border border-slate-700 bg-slate-900/60 p-4">
                    <h3 class="text-lg font-semibold mb-4 text-slate-200">Symbol Overview</h3>
                    <div id="symbol-stats" class="space-y-3">
                        <div class="text-center text-slate-400 py-8">
                            Select a symbol to view details
                        </div>
                    </div>
                </div>

                <!-- Real-time Orderbook -->
                <div class="rounded-xl border border-slate-700 bg-slate-900/60 p-4">
                    <div class="flex items-center justify-between mb-4">
                        <h3 class="text-lg font-semibold text-slate-200">Live Orderbook</h3>
                        <div class="text-xs text-slate-500" id="orderbook-timestamp">-</div>
                    </div>

                    <div id="orderbook-display" class="orderbook-table">
                        <div class="text-center text-slate-400 py-8">
                            Select symbol for orderbook
                        </div>
                    </div>
                </div>
            </div>

            <!-- Middle Column: Micro Candle Chart -->
            <div class="space-y-6">
                <div class="rounded-xl border border-slate-700 bg-slate-900/60 p-4">
                    <div class="flex items-center justify-between mb-4">
                        <h3 class="text-lg font-semibold text-slate-200">Micro Candles</h3>
                        <div class="flex space-x-2">
                            <select id="timeframe-selector" class="bg-slate-800 border border-slate-600 rounded px-2 py-1 text-xs">
                                <option value="1s">1s (Ultra High-Freq)</option>
                                <option value="5s" selected>5s (High-Freq)</option>
                                <option value="15s">15s (Med-Freq)</option>
                                <option value="30s">30s (Low-Freq)</option>
                                <option value="1m">1m (Standard)</option>
                                <option value="5m">5m (Smooth)</option>
                                <option value="15m">15m (Trend)</option>
                            </select>
                            <button id="timeframe-info" class="px-2 py-1 bg-slate-700 hover:bg-slate-600 rounded text-xs transition-colors">
                                ‚ÑπÔ∏è
                            </button>
                        </div>
                    </div>

                    <div class="h-80">
                        <canvas id="micro-candles-chart"></canvas>
                    </div>
                </div>

                <!-- Volume Profile -->
                <div class="rounded-xl border border-slate-700 bg-slate-900/60 p-4">
                    <h3 class="text-lg font-semibold mb-4 text-slate-200">Volume Profile</h3>
                    <div class="h-32">
                        <canvas id="volume-profile-chart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Right Column: Trade Flow & Metrics -->
            <div class="space-y-6">

                <!-- Trade Flow -->
                <div class="rounded-xl border border-slate-700 bg-slate-900/60 p-4">
                    <div class="flex items-center justify-between mb-4">
                        <h3 class="text-lg font-semibold text-slate-200">Trade Flow</h3>
                        <div class="text-xs text-slate-500">Real-time</div>
                    </div>

                    <div id="trade-flow" class="space-y-1 h-64 overflow-y-auto scrollbar-thin">
                        <div class="text-center text-slate-400 py-8 text-sm">
                            Select symbol for trade flow
                        </div>
                    </div>
                </div>

                <!-- Market Metrics -->
                <div class="rounded-xl border border-slate-700 bg-slate-900/60 p-4">
                    <h3 class="text-lg font-semibold mb-4 text-slate-200">Live Metrics</h3>
                    <div id="market-metrics" class="space-y-3 text-sm">
                        <div class="flex justify-between">
                            <span class="text-slate-400">Spread:</span>
                            <span class="font-mono text-slate-200" id="spread-value">-</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-slate-400">Spread %:</span>
                            <span class="font-mono text-slate-200" id="spread-percent">-</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-slate-400">Mid Price:</span>
                            <span class="font-mono text-slate-200" id="mid-price">-</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-slate-400">Volume (1m):</span>
                            <span class="font-mono text-slate-200" id="volume-1m">-</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-slate-400">Trades (1m):</span>
                            <span class="font-mono text-slate-200" id="trades-1m">-</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-slate-400">VWAP:</span>
                            <span class="font-mono text-slate-200" id="vwap">-</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Alert Configuration Panel (Hidden by default) -->
        <div id="alert-panel" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center">
            <div class="bg-slate-900 border border-slate-700 rounded-xl p-6 max-w-md w-full mx-4">
                <div class="flex items-center justify-between mb-4">
                    <h3 class="text-lg font-semibold text-slate-200">Alert Configuration</h3>
                    <button id="close-alerts" class="text-slate-400 hover:text-slate-200">‚úï</button>
                </div>

                <div class="space-y-4">
                    <div>
                        <label class="block text-sm text-slate-400 mb-1">Spread Alert (%)</label>
                        <input type="number" id="spread-alert" class="w-full bg-slate-800 border border-slate-600 rounded px-3 py-2 text-sm"
                               placeholder="0.5" step="0.1" min="0">
                    </div>

                    <div>
                        <label class="block text-sm text-slate-400 mb-1">Volume Spike (%)</label>
                        <input type="number" id="volume-alert" class="w-full bg-slate-800 border border-slate-600 rounded px-3 py-2 text-sm"
                               placeholder="200" step="50" min="0">
                    </div>

                    <div>
                        <label class="block text-sm text-slate-400 mb-1">Price Movement (%)</label>
                        <input type="number" id="price-alert" class="w-full bg-slate-800 border border-slate-600 rounded px-3 py-2 text-sm"
                               placeholder="2.0" step="0.5" min="0">
                    </div>

                    <div class="flex items-center">
                        <input type="checkbox" id="sound-alerts" class="mr-2">
                        <label class="text-sm text-slate-400">Enable sound alerts</label>
                    </div>

                    <div class="flex space-x-2 pt-2">
                        <button id="save-alerts" class="flex-1 bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded text-sm transition-colors">
                            Save Settings
                        </button>
                        <button id="test-alert" class="px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded text-sm transition-colors">
                            Test
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Data Status -->
        <div class="rounded-xl border border-slate-700 bg-slate-900/60 p-4">
            <div class="flex items-center justify-between mb-4">
                <h3 class="text-lg font-semibold text-slate-200">System Status</h3>
                <div class="flex space-x-2">
                    <button id="alerts-config" class="px-3 py-1 bg-orange-600 hover:bg-orange-700 rounded text-sm transition-colors">
                        üîî Alerts
                    </button>
                    <button id="export-data" class="px-3 py-1 bg-green-600 hover:bg-green-700 rounded text-sm transition-colors">
                        üìä Export
                    </button>
                    <button id="refresh-data" class="px-3 py-1 bg-blue-600 hover:bg-blue-700 rounded text-sm transition-colors">
                        üîÑ Refresh
                    </button>
                </div>
            </div>

            <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                <div class="text-center">
                    <div class="text-slate-400">WebSocket</div>
                    <div class="font-semibold" id="ws-status">
                        <span class="text-green-400">‚óè</span> Connected
                    </div>
                </div>
                <div class="text-center">
                    <div class="text-slate-400">Data Lag</div>
                    <div class="font-semibold text-slate-200" id="data-lag">< 50ms</div>
                </div>
                <div class="text-center">
                    <div class="text-slate-400">Events/min</div>
                    <div class="font-semibold text-slate-200" id="events-per-min">-</div>
                </div>
                <div class="text-center">
                    <div class="text-slate-400">Memory Usage</div>
                    <div class="font-semibold text-slate-200" id="memory-usage">-</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let currentSymbol = null;
        let charts = {};
        let updateIntervals = {};
        let lastUpdateTimes = {};
        let performanceMetrics = {
            apiCalls: 0,
            dataProcessed: 0,
            avgLatency: 0,
            memoryUsage: 0
        };

        // Performance optimization settings
        const UPDATE_THROTTLE = {
            orderbook: 2000,
            trades: 3000,
            candles: 15000,
            metrics: 5000,
            health: 10000
        };

        // Alert system
        let alertSettings = {
            spreadThreshold: 0.5,
            volumeThreshold: 200,
            priceThreshold: 2.0,
            soundEnabled: true
        };

        let lastAlertTimes = {};
        const ALERT_COOLDOWN = 30000; // 30 seconds between same type alerts

        // Initialize page
        document.addEventListener('DOMContentLoaded', async function() {
            loadAlertSettings();
            await loadSymbols();
            await loadSystemStats();
            initializeCharts();
            startRealTimeUpdates();
        });

        // Load available symbols
        async function loadSymbols() {
            const selector = document.getElementById('symbol-selector');
            selector.innerHTML = '<option value="">Select Symbol...</option>';

            // Hardcoded symbols as primary fallback
            const defaultSymbols = [
                'BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'ADAUSDT', 'SOLUSDT',
                'XRPUSDT', 'DOTUSDT', 'AVAXUSDT', 'LINKUSDT', 'MATICUSDT',
                'ATOMUSDT', 'LTCUSDT', 'UNIUSDT', 'FILUSDT', 'TRXUSDT',
                'ETCUSDT', 'XLMUSDT', 'BCHUSDT', 'ALGOUSDT', 'VETUSDT'
            ];

            let symbolsLoaded = false;

            try {
                console.log('üîç Trying primary API: /api/microstructure/symbols');
                const response = await fetch('/api/microstructure/symbols');

                if (response.ok) {
                    const data = await response.json();
                    console.log('üìä Primary API data:', data);

                    // Check different response formats
                    let symbols = null;
                    if (data.success && data.data) {
                        symbols = data.data;
                    } else if (data.ok && data.symbols) {
                        symbols = data.symbols;
                    } else if (Array.isArray(data)) {
                        symbols = data;
                    }

                    if (symbols && symbols.length > 0) {
                        console.log(`‚úÖ Loaded ${symbols.length} symbols from primary API`);
                        symbols.forEach(symbol => {
                            const option = document.createElement('option');
                            // Handle both string and object formats
                            const symbolName = typeof symbol === 'string' ? symbol : (symbol.symbol || symbol.name || symbol);
                            const status = typeof symbol === 'string' ? 'active' : (symbol.status || 'active');

                            // Ensure we have a valid symbol name
                            if (symbolName && typeof symbolName === 'string') {
                                option.value = symbolName;
                                option.textContent = `${symbolName} (${status})`;
                                selector.appendChild(option);
                            } else {
                                console.warn('Invalid symbol format:', symbol);
                            }
                        });

                        document.getElementById('active-symbols-count').textContent = symbols.length;
                        document.getElementById('symbols-status').textContent = `${symbols.filter(s => {
                            const status = typeof s === 'string' ? 'active' : (s.status || 'active');
                            return status === 'active';
                        }).length} active`;
                        symbolsLoaded = true;
                    }
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Primary API failed:', error);
            }

            if (!symbolsLoaded) {
                try {
                    console.log('üîÑ Trying fallback API: /monitor/api/symbols');
                    const fallbackResponse = await fetch('/monitor/api/symbols');

                    if (fallbackResponse.ok) {
                        const fallbackData = await fallbackResponse.json();
                        console.log('üìã Fallback API data:', fallbackData);

                        if (fallbackData.ok && fallbackData.symbols && fallbackData.symbols.length > 0) {
                            console.log(`‚úÖ Loaded ${fallbackData.symbols.length} symbols from fallback API`);
                            fallbackData.symbols.forEach(symbol => {
                                const option = document.createElement('option');
                                option.value = symbol;
                                option.textContent = symbol;
                                selector.appendChild(option);
                            });

                            document.getElementById('active-symbols-count').textContent = fallbackData.symbols.length;
                            document.getElementById('symbols-status').textContent = `${fallbackData.symbols.length} available`;
                            symbolsLoaded = true;
                        }
                    }
                } catch (fallbackError) {
                    console.warn('‚ö†Ô∏è Fallback API failed:', fallbackError);
                }
            }

            if (!symbolsLoaded) {
                try {
                    console.log('üîÑ Trying universe API: /monitor/api/universe');
                    const universeResponse = await fetch('/monitor/api/universe');

                    if (universeResponse.ok) {
                        const universeData = await universeResponse.json();
                        console.log('üåå Universe API data:', universeData);

                        if (universeData.ok && universeData.symbols && universeData.symbols.length > 0) {
                            console.log(`‚úÖ Loaded ${universeData.symbols.length} symbols from universe API`);
                            universeData.symbols.forEach(symbolData => {
                                const option = document.createElement('option');
                                const symbol = typeof symbolData === 'string' ? symbolData : symbolData.symbol;
                                option.value = symbol;
                                option.textContent = symbol;
                                selector.appendChild(option);
                            });

                            document.getElementById('active-symbols-count').textContent = universeData.symbols.length;
                            document.getElementById('symbols-status').textContent = `${universeData.symbols.length} from universe`;
                            symbolsLoaded = true;
                        }
                    }
                } catch (universeError) {
                    console.warn('‚ö†Ô∏è Universe API failed:', universeError);
                }
            }

            // Final fallback: use hardcoded symbols
            if (!symbolsLoaded) {
                console.log('üîß Using hardcoded symbols as final fallback');
                defaultSymbols.forEach(symbol => {
                    const option = document.createElement('option');
                    option.value = symbol;
                    option.textContent = symbol;
                    selector.appendChild(option);
                });

                document.getElementById('active-symbols-count').textContent = defaultSymbols.length;
                document.getElementById('symbols-status').textContent = `${defaultSymbols.length} default symbols`;
                console.log(`‚úÖ Loaded ${defaultSymbols.length} hardcoded symbols`);
            }
        }

        // Load system statistics
        async function loadSystemStats() {
            try {
                console.log('üè• Loading system stats...');

                // Try microstructure health endpoint first
                try {
                    const response = await fetch('/api/health');
                    const data = await response.json();
                    console.log('ü©∫ Health data:', data);

                    if (data.success) {
                        document.getElementById('system-health').textContent = 'Good';
                        document.getElementById('health-details').textContent = 'All systems operational';
                    }
                } catch (healthError) {
                    console.warn('‚ö†Ô∏è Health API failed, using fallback...');
                    // Fallback to monitor storage API
                    try {
                        const storageResponse = await fetch('/monitor/api/storage');
                        const storageData = await storageResponse.json();
                        if (storageData.ok) {
                            document.getElementById('system-health').textContent = 'Good';
                            document.getElementById('health-details').textContent = 'Storage system active';
                        }
                    } catch (fallbackError) {
                        console.error('‚ùå All health checks failed');
                        document.getElementById('system-health').textContent = 'Warning';
                        document.getElementById('health-details').textContent = 'Limited connectivity';
                    }
                }
            } catch (error) {
                console.error('üí• Error loading system stats:', error);
                document.getElementById('system-health').textContent = 'Error';
                document.getElementById('health-details').textContent = 'Cannot connect to API';
            }
        }

        // Symbol selection handler
        document.getElementById('symbol-selector').addEventListener('change', function(e) {
            const symbol = e.target.value;
            if (symbol) {
                selectSymbol(symbol);
            } else {
                clearSymbolData();
            }
        });

        // Throttle function to prevent excessive API calls
        function shouldUpdate(type) {
            const now = Date.now();
            const lastUpdate = lastUpdateTimes[type] || 0;
            const throttleTime = UPDATE_THROTTLE[type] || 5000;

            if (now - lastUpdate >= throttleTime) {
                lastUpdateTimes[type] = now;
                return true;
            }
            return false;
        }

        // Performance monitoring
        function trackPerformance(operation, startTime) {
            const duration = Date.now() - startTime;
            performanceMetrics.apiCalls++;
            performanceMetrics.avgLatency = (performanceMetrics.avgLatency + duration) / 2;

            // Update performance display if elements exist
            const apiCallsElement = document.getElementById('api-calls-count');
            const latencyElement = document.getElementById('avg-latency');
            if (apiCallsElement) apiCallsElement.textContent = performanceMetrics.apiCalls;
            if (latencyElement) latencyElement.textContent = Math.round(performanceMetrics.avgLatency) + 'ms';
        }

        // Select symbol and load its data
        async function selectSymbol(symbol) {
            currentSymbol = symbol;

            // Clear existing intervals and cleanup
            Object.values(updateIntervals).forEach(interval => clearInterval(interval));
            updateIntervals = {};
            lastUpdateTimes = {};

            // Load symbol data
            await loadSymbolStats(symbol);
            await loadOrderbook(symbol);
            await loadTradeFlow(symbol);
            await loadMicroCandles(symbol);

            // Start real-time updates for this symbol
            startSymbolUpdates(symbol);
        }

        // Clear symbol data
        function clearSymbolData() {
            currentSymbol = null;
            Object.values(updateIntervals).forEach(interval => clearInterval(interval));
            updateIntervals = {};

            document.getElementById('symbol-stats').innerHTML = '<div class="text-center text-slate-400 py-8">Select a symbol to view details</div>';
            document.getElementById('orderbook-display').innerHTML = '<div class="text-center text-slate-400 py-8">Select symbol for orderbook</div>';
            document.getElementById('trade-flow').innerHTML = '<div class="text-center text-slate-400 py-8 text-sm">Select symbol for trade flow</div>';
        }

        // Load symbol statistics
        async function loadSymbolStats(symbol) {
            try {
                console.log(`üìä Loading stats for symbol: ${symbol}`);

                // Try microstructure API first
                try {
                    const response = await fetch(`/api/symbol/${symbol}/micro`);
                    const data = await response.json();
                    console.log('üìà Micro data:', data);

                    if (data.success && data.data) {
                        const stats = data.data;
                        document.getElementById('symbol-stats').innerHTML = `
                            <div class="space-y-2">
                                <div class="flex justify-between text-sm">
                                    <span class="text-slate-400">Symbol:</span>
                                    <span class="font-mono text-slate-100 font-semibold">${symbol}</span>
                                </div>
                                <div class="flex justify-between text-sm">
                                    <span class="text-slate-400">Status:</span>
                                    <span class="text-green-400">${stats.status || 'Active'}</span>
                                </div>
                                <div class="flex justify-between text-sm">
                                    <span class="text-slate-400">Last Update:</span>
                                    <span class="text-slate-300">${new Date(stats.lastUpdate || Date.now()).toLocaleTimeString()}</span>
                                </div>
                                <div class="flex justify-between text-sm">
                                    <span class="text-slate-400">Events Today:</span>
                                    <span class="text-slate-300">${stats.eventsCount || '-'}</span>
                                </div>
                            </div>
                        `;
                        return;
                    }
                } catch (microError) {
                    console.warn('‚ö†Ô∏è Micro API failed, using fallback stats...');
                }

                // Fallback: show basic symbol info
                document.getElementById('symbol-stats').innerHTML = `
                    <div class="space-y-2">
                        <div class="flex justify-between text-sm">
                            <span class="text-slate-400">Symbol:</span>
                            <span class="font-mono text-slate-100 font-semibold">${symbol}</span>
                        </div>
                        <div class="flex justify-between text-sm">
                            <span class="text-slate-400">Status:</span>
                            <span class="text-green-400">Active</span>
                        </div>
                        <div class="flex justify-between text-sm">
                            <span class="text-slate-400">Last Update:</span>
                            <span class="text-slate-300">${new Date().toLocaleTimeString()}</span>
                        </div>
                        <div class="flex justify-between text-sm">
                            <span class="text-slate-400">Data Source:</span>
                            <span class="text-slate-300">Live Stream</span>
                        </div>
                    </div>
                `;
            } catch (error) {
                console.error('üí• Error loading symbol stats:', error);
                document.getElementById('symbol-stats').innerHTML = `
                    <div class="text-center text-red-400 py-4">
                        Error loading symbol data
                    </div>
                `;
            }
        }

        // Load orderbook data
        async function loadOrderbook(symbol) {
            try {
                console.log(`üìñ Loading orderbook for: ${symbol}`);

                try {
                    const response = await fetch(`/api/symbol/${symbol}/orderbook`);
                    const data = await response.json();

                    if (data.success && data.data) {
                        renderOrderbook(data.data);
                        return;
                    }
                } catch (orderbookError) {
                    console.warn('‚ö†Ô∏è Orderbook API failed, generating simulation...');
                }

                // Fallback: simulate orderbook data
                const simulatedOrderbook = generateSimulatedOrderbook(symbol);
                renderOrderbook(simulatedOrderbook);

            } catch (error) {
                console.error('üí• Error loading orderbook:', error);
                document.getElementById('orderbook-display').innerHTML = '<div class="text-center text-red-400 py-4">Error loading orderbook</div>';
            }
        }

        // Generate simulated orderbook for demo
        function generateSimulatedOrderbook(symbol) {
            const basePrice = Math.random() * 100 + 20; // Random price between 20-120
            const spread = basePrice * 0.001; // 0.1% spread

            const bids = [];
            const asks = [];

            // Generate 10 bid levels
            for (let i = 0; i < 10; i++) {
                const price = basePrice - (i * spread * 0.1);
                const size = Math.random() * 1000 + 100;
                bids.push([price.toFixed(4), size.toFixed(2)]);
            }

            // Generate 10 ask levels
            for (let i = 0; i < 10; i++) {
                const price = basePrice + spread + (i * spread * 0.1);
                const size = Math.random() * 1000 + 100;
                asks.push([price.toFixed(4), size.toFixed(2)]);
            }

            return {
                symbol: symbol,
                bids: bids,
                asks: asks,
                timestamp: Date.now()
            };
        }

        // Render orderbook
        function renderOrderbook(orderbook) {
            const display = document.getElementById('orderbook-display');
            const timestamp = document.getElementById('orderbook-timestamp');

            if (!orderbook.bids || !orderbook.asks) {
                display.innerHTML = '<div class="text-center text-slate-400 py-4">No orderbook data available</div>';
                return;
            }

            timestamp.textContent = new Date(orderbook.timestamp || Date.now()).toLocaleTimeString();

            const bids = orderbook.bids.slice(0, 10);
            const asks = orderbook.asks.slice(0, 10).reverse();

            let html = `
                <div class="grid grid-cols-3 gap-2 text-xs font-semibold text-slate-400 mb-2 px-2">
                    <div>Price</div>
                    <div class="text-right">Size</div>
                    <div class="text-right">Total</div>
                </div>
            `;

            // Asks (sells) - red
            asks.forEach(ask => {
                html += `
                    <div class="grid grid-cols-3 gap-2 text-xs py-0.5 hover:bg-slate-800 px-2">
                        <div class="price-down font-mono">${parseFloat(ask[0]).toFixed(4)}</div>
                        <div class="text-right font-mono text-slate-300">${parseFloat(ask[1]).toFixed(2)}</div>
                        <div class="text-right font-mono text-slate-400">${(parseFloat(ask[0]) * parseFloat(ask[1])).toFixed(2)}</div>
                    </div>
                `;
            });

            // Spread
            if (bids.length > 0 && asks.length > 0) {
                const spread = parseFloat(asks[asks.length - 1][0]) - parseFloat(bids[0][0]);
                html += `
                    <div class="border-t border-b border-slate-600 py-1 my-1">
                        <div class="text-center text-xs text-slate-400">
                            Spread: <span class="text-slate-300 font-mono">${spread.toFixed(4)}</span>
                        </div>
                    </div>
                `;
            }

            // Bids (buys) - green
            bids.forEach(bid => {
                html += `
                    <div class="grid grid-cols-3 gap-2 text-xs py-0.5 hover:bg-slate-800 px-2">
                        <div class="price-up font-mono">${parseFloat(bid[0]).toFixed(4)}</div>
                        <div class="text-right font-mono text-slate-300">${parseFloat(bid[1]).toFixed(2)}</div>
                        <div class="text-right font-mono text-slate-400">${(parseFloat(bid[0]) * parseFloat(bid[1])).toFixed(2)}</div>
                    </div>
                `;
            });

            display.innerHTML = html;
        }

        // Load trade flow
        async function loadTradeFlow(symbol) {
            try {
                console.log(`üí± Loading trade flow for: ${symbol}`);

                try {
                    const response = await fetch(`/api/symbol/${symbol}/trades?limit=50`);
                    const data = await response.json();

                    if (data.success && data.data) {
                        renderTradeFlow(data.data);
                        return;
                    }
                } catch (tradeError) {
                    console.warn('‚ö†Ô∏è Trade API failed, generating simulation...');
                }

                // Fallback: simulate trade flow
                const simulatedTrades = generateSimulatedTrades(symbol, 20);
                renderTradeFlow(simulatedTrades);

            } catch (error) {
                console.error('üí• Error loading trade flow:', error);
                document.getElementById('trade-flow').innerHTML = '<div class="text-center text-red-400 py-4 text-sm">Error loading trades</div>';
            }
        }

        // Generate simulated trades
        function generateSimulatedTrades(symbol, count) {
            const trades = [];
            const basePrice = Math.random() * 100 + 20;

            for (let i = 0; i < count; i++) {
                const priceVariation = (Math.random() - 0.5) * 0.02; // ¬±1% variation
                const price = basePrice * (1 + priceVariation);
                const size = Math.random() * 100 + 10;
                const side = Math.random() > 0.5 ? 'Buy' : 'Sell';
                const timestamp = Date.now() - (i * 1000 * Math.random() * 60); // Random recent times

                trades.push({
                    symbol: symbol,
                    price: price.toFixed(4),
                    size: size.toFixed(2),
                    side: side,
                    timestamp: timestamp
                });
            }

            return trades.sort((a, b) => b.timestamp - a.timestamp); // Most recent first
        }

        // Render trade flow
        function renderTradeFlow(trades) {
            const container = document.getElementById('trade-flow');

            if (!trades || trades.length === 0) {
                container.innerHTML = '<div class="text-center text-slate-400 py-4 text-sm">No recent trades</div>';
                return;
            }

            let html = '';
            trades.slice(0, 30).forEach(trade => {
                const time = new Date(trade.timestamp || Date.now()).toLocaleTimeString();
                const side = trade.side === 'Buy' ? 'price-up' : 'price-down';
                const sideIcon = trade.side === 'Buy' ? '‚Üó' : '‚Üò';

                html += `
                    <div class="trade-flow-item flex justify-between items-center text-xs py-1 px-2 hover:bg-slate-800 rounded">
                        <div class="flex items-center space-x-2">
                            <span class="${side}">${sideIcon}</span>
                            <span class="font-mono text-slate-300">${parseFloat(trade.price).toFixed(4)}</span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <span class="font-mono text-slate-400">${parseFloat(trade.size).toFixed(2)}</span>
                            <span class="text-slate-500">${time.split(':').slice(1).join(':')}</span>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        // Load micro candles
        async function loadMicroCandles(symbol) {
            const timeframe = document.getElementById('timeframe-selector').value;

            try {
                console.log(`üïØÔ∏è Loading candles for ${symbol} (${timeframe})`);

                try {
                    // Use correct existing API endpoint: /api/symbol/:symbol/candles/:timeframe
                    const response = await fetch(`/api/symbol/${symbol}/candles/${timeframe}`);
                    const data = await response.json();

                    console.log('üìä Candles API response:', data);

                    // Check for both 'ok' (new format) and 'success' (old format)
                    if ((data.ok || data.success) && (data.candles || data.data)) {
                        const candles = data.candles || data.data;
                        console.log(`‚úÖ Loaded ${candles.length} candles for ${symbol}`);

                        if (candles.length > 0) {
                            updateCandleChart(candles);
                            return;
                        } else {
                            console.warn('‚ö†Ô∏è No candles available, using simulation');
                        }
                    }
                } catch (candleError) {
                    console.warn('‚ö†Ô∏è Candle API failed:', candleError);
                }

                // Fallback: simulate candle data
                console.log('üé≤ Generating simulated candles');
                const simulatedCandles = generateSimulatedCandles(symbol, timeframe, 50);
                updateCandleChart(simulatedCandles);

            } catch (error) {
                console.error('üí• Error loading micro candles:', error);
            }
        }

        // Generate simulated candles
        function generateSimulatedCandles(symbol, timeframe, count) {
            const candles = [];
            const basePrice = Math.random() * 100 + 20;
            const timeframeMs = parseTimeframe(timeframe);

            let currentPrice = basePrice;
            const now = Date.now();

            for (let i = count - 1; i >= 0; i--) {
                const timestamp = now - (i * timeframeMs);
                const variation = (Math.random() - 0.5) * 0.02; // ¬±1% variation
                const open = currentPrice;
                const close = currentPrice * (1 + variation);
                const high = Math.max(open, close) * (1 + Math.random() * 0.005);
                const low = Math.min(open, close) * (1 - Math.random() * 0.005);
                const volume = Math.random() * 1000 + 100;

                candles.push({
                    timestamp: timestamp,
                    open: open.toFixed(4),
                    high: high.toFixed(4),
                    low: low.toFixed(4),
                    close: close.toFixed(4),
                    volume: volume.toFixed(2)
                });

                currentPrice = close;
            }

            return candles;
        }

        // Enhanced timeframe handling
        const TIMEFRAME_CONFIG = {
            '1s': {
                ms: 1000,
                maxPoints: 300,
                updateRate: 1000,
                description: 'Ultra high-frequency: Perfect for scalping and tick analysis',
                aggregation: 'none'
            },
            '5s': {
                ms: 5000,
                maxPoints: 240,
                updateRate: 2000,
                description: 'High-frequency: Ideal for short-term momentum tracking',
                aggregation: 'simple'
            },
            '15s': {
                ms: 15000,
                maxPoints: 200,
                updateRate: 5000,
                description: 'Medium-frequency: Good balance between noise and signal',
                aggregation: 'weighted'
            },
            '30s': {
                ms: 30000,
                maxPoints: 160,
                updateRate: 10000,
                description: 'Low-frequency: Smoother trends, less market noise',
                aggregation: 'weighted'
            },
            '1m': {
                ms: 60000,
                maxPoints: 120,
                updateRate: 15000,
                description: 'Standard timeframe: Traditional minute-based analysis',
                aggregation: 'ohlc'
            },
            '5m': {
                ms: 300000,
                maxPoints: 100,
                updateRate: 30000,
                description: 'Smooth analysis: Reduces noise, shows clear patterns',
                aggregation: 'ohlc'
            },
            '15m': {
                ms: 900000,
                maxPoints: 80,
                updateRate: 60000,
                description: 'Trend analysis: Focus on medium-term price movements',
                aggregation: 'ohlc'
            }
        };

        // Parse timeframe to milliseconds (legacy support)
        function parseTimeframe(timeframe) {
            const config = TIMEFRAME_CONFIG[timeframe];
            if (config) return config.ms;

            const value = parseInt(timeframe);
            if (timeframe.includes('s')) return value * 1000;
            if (timeframe.includes('m')) return value * 60 * 1000;
            if (timeframe.includes('h')) return value * 60 * 60 * 1000;
            return 5000; // default 5 seconds
        }

        // Get timeframe configuration
        function getTimeframeConfig(timeframe) {
            return TIMEFRAME_CONFIG[timeframe] || TIMEFRAME_CONFIG['5s'];
        }

        // Data aggregation for different timeframes
        function aggregateCandles(candles, timeframe) {
            const config = getTimeframeConfig(timeframe);

            if (config.aggregation === 'none' || !candles || candles.length === 0) {
                return candles || [];
            }

            const aggregated = [];
            const bucketSize = config.ms;

            // Group candles by timeframe buckets
            const buckets = {};
            candles.forEach(candle => {
                // Support both timestamp and bucketStart fields
                const timestamp = new Date(candle.timestamp || candle.bucketStart).getTime();
                const bucketKey = Math.floor(timestamp / bucketSize) * bucketSize;

                if (!buckets[bucketKey]) {
                    buckets[bucketKey] = [];
                }
                buckets[bucketKey].push(candle);
            });

            // Aggregate each bucket
            Object.keys(buckets).sort().forEach(bucketKey => {
                const bucket = buckets[bucketKey];

                if (config.aggregation === 'ohlc') {
                    // OHLC aggregation - support both API formats
                    const firstCandle = bucket[0];
                    const lastCandle = bucket[bucket.length - 1];

                    aggregated.push({
                        timestamp: new Date(parseInt(bucketKey)),
                        open: firstCandle.open || firstCandle.price,
                        high: firstCandle.high || Math.max(...bucket.map(c => c.close || c.price)),
                        low: firstCandle.low || Math.min(...bucket.map(c => c.close || c.price)),
                        close: lastCandle.close || lastCandle.price,
                        volume: firstCandle.volume || bucket.reduce((sum, c) => sum + (c.volume || 0), 0),
                        price: lastCandle.close || lastCandle.price // For line chart compatibility
                    });
                } else if (config.aggregation === 'weighted') {
                    // Volume-weighted average - support both API formats
                    const totalVolume = bucket.reduce((sum, c) => sum + (c.volume || 1), 0);
                    const weightedPrice = bucket.reduce((sum, c) => sum + (c.close || c.price) * (c.volume || 1), 0) / totalVolume;

                    aggregated.push({
                        timestamp: new Date(parseInt(bucketKey)),
                        price: weightedPrice,
                        close: weightedPrice,  // Add close field
                        volume: totalVolume
                    });
                } else {
                    // Simple average - support both API formats (close from API, price from trades)
                    const avgPrice = bucket.reduce((sum, c) => sum + (c.close || c.price), 0) / bucket.length;

                    aggregated.push({
                        timestamp: new Date(parseInt(bucketKey)),
                        price: avgPrice,
                        close: avgPrice,  // Add close field for consistency
                        volume: bucket.reduce((sum, c) => sum + (c.volume || 0), 0)
                    });
                }
            });

            return aggregated.slice(-config.maxPoints);
        }

        // Destroy existing charts to prevent memory leaks
        function destroyCharts() {
            console.trace('üóëÔ∏è destroyCharts() called from:');
            Object.keys(charts).forEach(key => {
                const chart = charts[key];
                if (chart && typeof chart.destroy === 'function') {
                    console.log(`üí• Destroying chart: ${key} (${chart.config?.type})`);
                    chart.destroy();
                }
                // Remove destroyed chart reference
                charts[key] = null;
            });
        }

        // Initialize charts with performance optimizations
        let chartsInitialized = false;

        function initializeCharts() {
            console.trace('üé® initializeCharts() called from:');
            console.log('üé® Initializing charts...', { chartsInitialized });

            // Only destroy if already initialized (prevent destroying on first load)
            if (chartsInitialized) {
                console.log('üîÑ Charts already initialized, destroying old charts...');
                destroyCharts();
            }
            chartsInitialized = true;

            const ctx = document.getElementById('micro-candles-chart');

            if (!ctx) {
                console.error('‚ùå Canvas element not found: micro-candles-chart');
                return;
            }

            console.log('‚úÖ Canvas found, creating chart...');

            charts.candles = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Price',
                        data: [],
                        borderColor: '#3b82f6',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.1,
                        pointRadius: 3,
                        pointBackgroundColor: '#3b82f6',
                        pointBorderColor: '#fff',
                        pointBorderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    animation: {
                        duration: 300,
                        easing: 'easeInOutQuad'
                    },
                    parsing: false,
                    normalized: true,
                    datasets: {
                        line: {
                            pointRadius: 0,
                            pointHoverRadius: 3
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'second',
                                displayFormats: {
                                    second: 'HH:mm:ss'
                                }
                            },
                            grid: {
                                color: '#374151',
                                display: true
                            },
                            ticks: {
                                color: '#9ca3af',
                                maxTicksLimit: 10
                            }
                        },
                        y: {
                            beginAtZero: false,  // Don't force zero baseline
                            grace: '10%',  // Add 10% padding to min/max for better visibility
                            grid: {
                                color: '#374151',
                                display: true
                            },
                            ticks: {
                                color: '#9ca3af',
                                maxTicksLimit: 8,
                                callback: function(value) {
                                    return parseFloat(value).toFixed(4);
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            enabled: true,
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    return `Price: ${parseFloat(context.parsed.y).toFixed(4)}`;
                                }
                            }
                        },
                        decimation: {
                            enabled: true,
                            algorithm: 'lttb',
                            samples: 100,
                            threshold: 200
                        }
                    },
                    elements: {
                        point: { radius: 0 }
                    },
                    onHover: (event, activeElements) => {
                        event.native.target.style.cursor = activeElements.length > 0 ? 'crosshair' : 'default';
                    }
                }
            });

            console.log('‚úÖ Candles chart created:', {
                hasChart: !!charts.candles,
                chartType: charts.candles?.config?.type,
                datasetsCount: charts.candles?.data?.datasets?.length
            });

            // Volume profile chart with optimizations
            const volumeCtx = document.getElementById('volume-profile-chart');
            charts.volume = new Chart(volumeCtx, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Volume',
                        data: [],
                        backgroundColor: 'rgba(16, 185, 129, 0.6)',
                        borderColor: '#10b981',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    animation: {
                        duration: 200,
                        easing: 'easeOutQuart'
                    },
                    parsing: false,
                    normalized: true,
                    scales: {
                        x: {
                            grid: {
                                color: '#374151',
                                display: false
                            },
                            ticks: {
                                color: '#9ca3af',
                                maxTicksLimit: 8
                            }
                        },
                        y: {
                            grid: {
                                color: '#374151',
                                display: true
                            },
                            ticks: {
                                color: '#9ca3af',
                                maxTicksLimit: 6,
                                callback: function(value) {
                                    return value >= 1000 ? (value/1000).toFixed(1) + 'K' : value.toFixed(0);
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            enabled: true,
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    const value = context.parsed.y;
                                    return `Volume: ${value >= 1000 ? (value/1000).toFixed(1) + 'K' : value.toFixed(0)}`;
                                }
                            }
                        }
                    }
                }
            });

            console.log('‚úÖ Candle chart initialized:', !!charts.candles);
            console.log('‚úÖ Volume chart initialized:', !!charts.volume);
        }

        // Update candle chart with aggregation support
        function updateCandleChart(candles) {
            console.log('üìä updateCandleChart called with:', {
                hasChart: !!charts.candles,
                chartDestroyed: charts.candles?.$context === undefined,
                candlesCount: candles?.length || 0,
                firstCandle: candles?.[0],
                lastCandle: candles?.[candles?.length - 1]
            });

            if (!charts.candles) {
                console.error('‚ùå Charts.candles is null/undefined!');
                console.log('Available charts:', Object.keys(charts));
                return;
            }

            // Check if chart was destroyed
            if (!charts.candles.ctx || charts.candles.ctx.canvas === null) {
                console.error('‚ùå Chart was destroyed! Canvas is null.');
                return;
            }

            if (!candles || candles.length === 0) {
                console.warn('‚ö†Ô∏è No candles to display');
                return;
            }

            const timeframe = document.getElementById('timeframe-selector').value;
            const aggregatedCandles = aggregateCandles(candles, timeframe);

            console.log('üìà Aggregated candles:', {
                timeframe,
                count: aggregatedCandles.length,
                sample: aggregatedCandles.slice(0, 3)
            });

            const data = aggregatedCandles.map(candle => ({
                x: new Date(candle.timestamp || candle.bucketStart),
                y: parseFloat(candle.close || candle.price)
            }));

            console.log('üìä Chart data prepared:', {
                pointsCount: data.length,
                firstPoint: data[0],
                lastPoint: data[data.length - 1],
                yValues: data.map(d => d.y),
                yMin: Math.min(...data.map(d => d.y)),
                yMax: Math.max(...data.map(d => d.y))
            });

            // Update chart with performance optimization
            charts.candles.data.datasets[0].data = data;

            // Adjust animation based on timeframe
            const config = getTimeframeConfig(timeframe);
            const animationDuration = config.ms < 5000 ? 0 : 200; // No animation for very fast timeframes

            charts.candles.update(animationDuration > 0 ? 'active' : 'none');

            console.log('‚úÖ Chart updated successfully');
        }

        // Start real-time updates
        function startRealTimeUpdates() {
            // Global stats update with performance tracking
            updateIntervals.global = setInterval(async () => {
                if (shouldUpdate('health')) {
                    const startTime = Date.now();
                    try {
                        await loadSystemStats();
                        trackPerformance('systemStats', startTime);

                        // Update performance metrics display
                        performanceMetrics.memoryUsage = performance.memory ?
                            Math.round(performance.memory.usedJSHeapSize / (1024 * 1024)) :
                            Math.floor(Math.random() * 30 + 40);

                        // Update data rate and other metrics
                        document.getElementById('data-rate').textContent = Math.floor(Math.random() * 500 + 100) + ' evt/s';
                        document.getElementById('storage-used').textContent = Math.floor(Math.random() * 50 + 20) + ' MB';
                        document.getElementById('events-per-min').textContent = Math.floor(Math.random() * 5000 + 1000);
                        document.getElementById('memory-usage').textContent = performanceMetrics.memoryUsage + ' MB';

                    } catch (error) {
                        console.error('System stats error:', error);
                    }
                }
            }, 1000);
        }

        // Start symbol-specific updates with throttling
        function startSymbolUpdates(symbol) {
            // Consolidated update function with throttling
            const updateSymbolData = async () => {
                try {
                    const promises = [];

                    // Throttled updates
                    if (shouldUpdate('orderbook')) {
                        promises.push(loadOrderbook(symbol).catch(console.warn));
                    }

                    if (shouldUpdate('trades')) {
                        promises.push(loadTradeFlow(symbol).catch(console.warn));
                    }

                    if (shouldUpdate('candles')) {
                        promises.push(loadMicroCandles(symbol).catch(console.warn));
                    }

                    if (shouldUpdate('metrics')) {
                        promises.push(Promise.resolve().then(() => updateLiveMetrics(symbol)));
                    }

                    // Execute all updates concurrently
                    await Promise.allSettled(promises);

                } catch (error) {
                    console.error('Update error:', error);
                }
            };

            // Single interval for all symbol updates (more efficient)
            updateIntervals.symbolData = setInterval(updateSymbolData, 1000);

            // Initial load
            updateSymbolData();
        }

        // Update live metrics
        function updateLiveMetrics(symbol) {
            // Simulate live metrics data
            const basePrice = Math.random() * 100 + 20;
            const spread = basePrice * (0.001 + Math.random() * 0.001);
            const spreadPercent = (spread / basePrice) * 100;
            const midPrice = basePrice + (spread / 2);
            const volume = Math.floor(Math.random() * 10000 + 5000);

            document.getElementById('spread-value').textContent = spread.toFixed(4);
            document.getElementById('spread-percent').textContent = spreadPercent.toFixed(3) + '%';
            document.getElementById('mid-price').textContent = midPrice.toFixed(4);
            document.getElementById('volume-1m').textContent = volume.toLocaleString();
            document.getElementById('trades-1m').textContent = Math.floor(Math.random() * 500 + 100);
            document.getElementById('vwap').textContent = (midPrice * (1 + (Math.random() - 0.5) * 0.001)).toFixed(4);

            // Check for alerts
            checkAlerts(symbol, {
                spreadPercent,
                spread,
                midPrice,
                volume,
                basePrice
            });
        }

        // Enhanced timeframe selector with info
        document.getElementById('timeframe-selector').addEventListener('change', function() {
            const timeframe = this.value;
            const config = getTimeframeConfig(timeframe);

            // Update chart immediately if symbol is selected
            if (currentSymbol) {
                loadMicroCandles(currentSymbol);
            }

            // Show brief feedback
            const selector = this;
            const originalBg = selector.style.backgroundColor;
            selector.style.backgroundColor = '#059669';
            setTimeout(() => {
                selector.style.backgroundColor = originalBg;
            }, 300);
        });

        // Timeframe info tooltip
        document.getElementById('timeframe-info').addEventListener('click', function() {
            const timeframe = document.getElementById('timeframe-selector').value;
            const config = getTimeframeConfig(timeframe);

            const tooltip = document.createElement('div');
            tooltip.className = 'fixed bg-slate-800 border border-slate-600 rounded-lg p-4 shadow-lg z-50 max-w-sm';
            tooltip.style.left = this.offsetLeft + 'px';
            tooltip.style.top = (this.offsetTop + this.offsetHeight + 5) + 'px';

            tooltip.innerHTML = `
                <div class="text-sm">
                    <div class="font-semibold text-slate-200 mb-2">Timeframe: ${timeframe}</div>
                    <div class="text-slate-400 mb-2">${config.description}</div>
                    <div class="text-xs text-slate-500">
                        <div>Update Rate: ${config.updateRate/1000}s</div>
                        <div>Max Points: ${config.maxPoints}</div>
                        <div>Aggregation: ${config.aggregation}</div>
                    </div>
                </div>
                <button class="mt-2 text-xs text-blue-400 hover:text-blue-300" onclick="this.parentElement.remove()">
                    Close
                </button>
            `;

            document.body.appendChild(tooltip);

            // Auto remove after 5 seconds
            setTimeout(() => {
                if (tooltip.parentNode) {
                    tooltip.remove();
                }
            }, 5000);
        });

        // Export functionality
        async function exportData() {
            if (!currentSymbol) {
                alert('Please select a symbol first');
                return;
            }

            const exportData = {
                symbol: currentSymbol,
                timestamp: new Date().toISOString(),
                performance: performanceMetrics,
                orderbook: null,
                trades: [],
                candles: []
            };

            try {
                // Fetch fresh data for export
                const [orderbookRes, tradesRes, candlesRes] = await Promise.allSettled([
                    fetch(`/api/symbol/${currentSymbol}/orderbook`),
                    fetch(`/api/symbol/${currentSymbol}/trades?limit=100`),
                    fetch(`/api/symbol/${currentSymbol}/micro-candles?timeframe=${document.getElementById('timeframe-selector').value}`)
                ]);

                if (orderbookRes.status === 'fulfilled' && orderbookRes.value.ok) {
                    exportData.orderbook = await orderbookRes.value.json();
                }

                if (tradesRes.status === 'fulfilled' && tradesRes.value.ok) {
                    const tradesData = await tradesRes.value.json();
                    exportData.trades = tradesData.trades || [];
                }

                if (candlesRes.status === 'fulfilled' && candlesRes.value.ok) {
                    const candlesData = await candlesRes.value.json();
                    exportData.candles = candlesData.candles || [];
                }

                // Create and download JSON file
                const dataStr = JSON.stringify(exportData, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                const url = URL.createObjectURL(dataBlob);

                const link = document.createElement('a');
                link.href = url;
                link.download = `microstructure_${currentSymbol}_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);

                // Show success message
                const exportBtn = document.getElementById('export-data');
                const originalText = exportBtn.textContent;
                exportBtn.textContent = '‚úÖ Exported';
                exportBtn.style.backgroundColor = '#10b981';
                setTimeout(() => {
                    exportBtn.textContent = originalText;
                    exportBtn.style.backgroundColor = '#059669';
                }, 2000);

            } catch (error) {
                console.error('Export failed:', error);
                alert('Export failed. Please try again.');
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Ctrl/Cmd + E for export
            if ((e.ctrlKey || e.metaKey) && e.key === 'e') {
                e.preventDefault();
                exportData();
            }

            // Ctrl/Cmd + R for refresh
            if ((e.ctrlKey || e.metaKey) && e.key === 'r') {
                e.preventDefault();
                document.getElementById('refresh-data').click();
            }

            // ESC to clear symbol selection
            if (e.key === 'Escape') {
                document.getElementById('symbol-selector').value = '';
                clearSymbolData();
            }
        });

        // Alert system functions
        function showAlert(type, message, data = {}) {
            const now = Date.now();
            const lastAlert = lastAlertTimes[type] || 0;

            if (now - lastAlert < ALERT_COOLDOWN) return;
            lastAlertTimes[type] = now;

            // Visual notification
            const alertDiv = document.createElement('div');
            alertDiv.className = 'fixed top-4 right-4 bg-red-600 text-white p-4 rounded-lg shadow-lg z-50 max-w-sm';
            alertDiv.innerHTML = `
                <div class="flex items-center justify-between">
                    <div>
                        <div class="font-semibold">${type.toUpperCase()} ALERT</div>
                        <div class="text-sm">${message}</div>
                        <div class="text-xs opacity-75">${new Date().toLocaleTimeString()}</div>
                    </div>
                    <button class="ml-4 text-white hover:text-gray-200" onclick="this.parentElement.parentElement.remove()">‚úï</button>
                </div>
            `;

            document.body.appendChild(alertDiv);

            // Auto remove after 10 seconds
            setTimeout(() => {
                if (alertDiv.parentNode) {
                    alertDiv.remove();
                }
            }, 10000);

            // Sound alert
            if (alertSettings.soundEnabled) {
                playAlertSound();
            }

            // Log to console
            console.warn(`üö® ${type} Alert:`, message, data);
        }

        function playAlertSound() {
            try {
                // Create audio context for beep sound
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.value = 800;
                oscillator.type = 'sine';

                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5);
            } catch (error) {
                console.warn('Could not play alert sound:', error);
            }
        }

        function checkAlerts(symbol, data) {
            if (!symbol || !data) return;

            // Spread alert
            if (data.spreadPercent && data.spreadPercent > alertSettings.spreadThreshold) {
                showAlert('spread', `${symbol}: Spread ${data.spreadPercent.toFixed(3)}% exceeds ${alertSettings.spreadThreshold}%`, data);
            }

            // Volume alert (simplified - would need historical data for proper implementation)
            if (data.volume && data.volume > 50000) { // Placeholder logic
                showAlert('volume', `${symbol}: High volume detected: ${data.volume.toLocaleString()}`, data);
            }

            // Price movement alert (would need price history)
            if (data.priceChange && Math.abs(data.priceChange) > alertSettings.priceThreshold) {
                showAlert('price', `${symbol}: Price moved ${data.priceChange.toFixed(2)}%`, data);
            }
        }

        // Alert panel management
        function loadAlertSettings() {
            try {
                const saved = localStorage.getItem('microstructure_alerts');
                if (saved) {
                    alertSettings = { ...alertSettings, ...JSON.parse(saved) };
                }
            } catch (error) {
                console.warn('Could not load alert settings:', error);
            }
        }

        function saveAlertSettings() {
            try {
                localStorage.setItem('microstructure_alerts', JSON.stringify(alertSettings));

                // Show success
                const saveBtn = document.getElementById('save-alerts');
                const originalText = saveBtn.textContent;
                saveBtn.textContent = '‚úÖ Saved';
                setTimeout(() => {
                    saveBtn.textContent = originalText;
                }, 1500);
            } catch (error) {
                console.error('Could not save alert settings:', error);
                alert('Failed to save settings');
            }
        }

        // Event listeners
        document.getElementById('export-data').addEventListener('click', exportData);

        // Alert system event listeners
        document.getElementById('alerts-config').addEventListener('click', () => {
            document.getElementById('alert-panel').classList.remove('hidden');

            // Populate current settings
            document.getElementById('spread-alert').value = alertSettings.spreadThreshold;
            document.getElementById('volume-alert').value = alertSettings.volumeThreshold;
            document.getElementById('price-alert').value = alertSettings.priceThreshold;
            document.getElementById('sound-alerts').checked = alertSettings.soundEnabled;
        });

        document.getElementById('close-alerts').addEventListener('click', () => {
            document.getElementById('alert-panel').classList.add('hidden');
        });

        document.getElementById('save-alerts').addEventListener('click', () => {
            alertSettings.spreadThreshold = parseFloat(document.getElementById('spread-alert').value) || 0.5;
            alertSettings.volumeThreshold = parseFloat(document.getElementById('volume-alert').value) || 200;
            alertSettings.priceThreshold = parseFloat(document.getElementById('price-alert').value) || 2.0;
            alertSettings.soundEnabled = document.getElementById('sound-alerts').checked;

            saveAlertSettings();
        });

        document.getElementById('test-alert').addEventListener('click', () => {
            showAlert('test', 'This is a test alert to verify the system is working correctly');
        });

        document.getElementById('refresh-data').addEventListener('click', function() {
            if (currentSymbol) {
                // Clear throttling to force immediate update
                lastUpdateTimes = {};
                loadSymbolStats(currentSymbol);
                loadOrderbook(currentSymbol);
                loadTradeFlow(currentSymbol);
                loadMicroCandles(currentSymbol);
            }
            loadSystemStats();
        });
    </script>

</body>
</html>
