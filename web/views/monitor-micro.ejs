<!DOCTYPE html>
<html lang="sr" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %> | DTrade AI</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        slate: {
                            850: '#1e293b',
                            950: '#020617'
                        }
                    }
                }
            }
        }
    </script>

    <!-- Chart.js for real-time charts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>

    <style>
        .orderbook-table {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 11px;
        }
        .price-up { color: #10b981; }
        .price-down { color: #ef4444; }
        .price-neutral { color: #94a3b8; }

        .trade-flow-item {
            transition: all 0.3s ease;
            opacity: 0;
            animation: fadeInSlide 0.5s forwards;
        }

        @keyframes fadeInSlide {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .micro-widget {
            background: linear-gradient(135deg, rgba(51, 65, 85, 0.6) 0%, rgba(30, 41, 59, 0.8) 100%);
            backdrop-filter: blur(10px);
        }
    </style>
</head>

<body class="bg-slate-950 text-slate-100 min-h-screen">

    <div class="w-full px-6 py-6 space-y-6">        <!-- Header -->
        <div class="flex items-center justify-between">
            <div>
                <h1 class="text-3xl font-bold tracking-tight">Microstructure Monitor</h1>
                <p class="text-slate-400 mt-1">FAZA 3 - Real-time market microstructure analysis</p>
                <p class="text-xs text-slate-500 mt-1">Last updated: <%= currentTime %></p>
            </div>
            <div class="flex items-center space-x-3">
                <div class="flex items-center space-x-2 text-sm">
                    <div class="w-3 h-3 rounded-full bg-green-400 animate-pulse"></div>
                    <span class="text-green-400 font-medium">Live Data</span>
                </div>
                <select id="symbol-selector" class="bg-slate-800 border border-slate-700 rounded px-3 py-1 text-sm text-slate-200">
                    <option value="">Select Symbol...</option>
                </select>
            </div>
        </div>

        <!-- Microstructure Overview Cards -->
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
            <div class="micro-widget rounded-xl border border-slate-700 p-4">
                <div class="text-xs text-slate-400 mb-1">Active Symbols</div>
                <div class="text-2xl font-bold text-slate-100" id="active-symbols-count">-</div>
                <div class="text-xs text-slate-500 mt-1" id="symbols-status">Loading...</div>
            </div>

            <div class="micro-widget rounded-xl border border-slate-700 p-4">
                <div class="text-xs text-slate-400 mb-1">Data Rate</div>
                <div class="text-2xl font-bold text-blue-400" id="data-rate">- evt/s</div>
                <div class="text-xs text-slate-500 mt-1">Events per second</div>
            </div>

            <div class="micro-widget rounded-xl border border-slate-700 p-4">
                <div class="text-xs text-slate-400 mb-1">Storage Used</div>
                <div class="text-2xl font-bold text-emerald-400" id="storage-used">- MB</div>
                <div class="text-xs text-slate-500 mt-1">Today's data</div>
            </div>

            <div class="micro-widget rounded-xl border border-slate-700 p-4">
                <div class="text-xs text-slate-400 mb-1">System Health</div>
                <div class="text-2xl font-bold text-green-400" id="system-health">Good</div>
                <div class="text-xs text-slate-500 mt-1" id="health-details">All systems operational</div>
            </div>
        </div>

        <!-- Main Content Grid -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">

            <!-- Left Column: Symbol Selection & Orderbook -->
            <div class="space-y-6">

                <!-- Symbol Stats -->
                <div class="rounded-xl border border-slate-700 bg-slate-900/60 p-4">
                    <h3 class="text-lg font-semibold mb-4 text-slate-200">Symbol Overview</h3>
                    <div id="symbol-stats" class="space-y-3">
                        <div class="text-center text-slate-400 py-8">
                            Select a symbol to view details
                        </div>
                    </div>
                </div>

                <!-- Real-time Orderbook -->
                <div class="rounded-xl border border-slate-700 bg-slate-900/60 p-4">
                    <div class="flex items-center justify-between mb-4">
                        <div class="flex items-center space-x-2">
                            <h3 class="text-lg font-semibold text-slate-200">Live Orderbook</h3>
                            <button onclick="showHelpModal('orderbook')" class="text-blue-400 hover:text-blue-300 transition-colors">
                                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"/>
                                </svg>
                            </button>
                        </div>
                        <div class="text-xs text-slate-500" id="orderbook-timestamp">-</div>
                    </div>

                    <!-- CURRENT PRICE DISPLAY -->
                    <div class="mb-6 p-4 rounded-lg bg-gradient-to-r from-slate-800 to-slate-900 border border-slate-600">
                        <div class="text-center">
                            <div class="text-xs text-slate-400 mb-1">CURRENT PRICE</div>
                            <div id="current-price" class="text-4xl font-bold text-green-400 mb-2">-</div>
                            <div class="flex justify-center space-x-6 text-xs">
                                <div>
                                    <span class="text-slate-400">Bid:</span>
                                    <span id="best-bid" class="text-green-400 font-mono ml-1">-</span>
                                </div>
                                <div>
                                    <span class="text-slate-400">Ask:</span>
                                    <span id="best-ask" class="text-red-400 font-mono ml-1">-</span>
                                </div>
                                <div>
                                    <span class="text-slate-400">Spread:</span>
                                    <span id="current-spread" class="text-blue-400 font-mono ml-1">-</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div id="orderbook-display" class="orderbook-table">
                        <div class="text-center text-slate-400 py-8">
                            Select symbol for orderbook
                        </div>
                    </div>
                </div>
            </div>

            <!-- Middle Column: Micro Candle Chart -->
            <div class="space-y-6">
                <div class="rounded-xl border border-slate-700 bg-slate-900/60 p-4">
                    <div class="flex items-center justify-between mb-4">
                        <div class="flex items-center space-x-2">
                            <h3 class="text-lg font-semibold text-slate-200">Micro Candles</h3>
                            <button onclick="showHelpModal('microCandles')" class="text-blue-400 hover:text-blue-300 transition-colors">
                                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"/>
                                </svg>
                            </button>
                        </div>
                        <div class="flex space-x-2">
                            <select id="timeframe-selector" class="bg-slate-800 border border-slate-600 rounded px-2 py-1 text-xs">
                                <option value="1s">1s (Ultra High-Freq)</option>
                                <option value="5s" selected>5s (High-Freq)</option>
                                <option value="15s">15s (Med-Freq)</option>
                                <option value="30s">30s (Low-Freq)</option>
                                <option value="1m">1m (Standard)</option>
                                <option value="5m">5m (Smooth)</option>
                                <option value="15m">15m (Trend)</option>
                            </select>
                            <button id="timeframe-info" class="px-2 py-1 bg-slate-700 hover:bg-slate-600 rounded text-xs transition-colors">
                                ‚ÑπÔ∏è
                            </button>
                        </div>
                    </div>

                    <div class="h-80">
                        <canvas id="micro-candles-chart"></canvas>
                    </div>
                </div>

                <!-- Volume Profile -->
                <div class="rounded-xl border border-slate-700 bg-slate-900/60 p-4">
                    <div class="flex items-center justify-between mb-4">
                        <div class="flex items-center space-x-2">
                            <h3 class="text-lg font-semibold text-slate-200">Volume Profile</h3>
                            <button onclick="showHelpModal('volumeProfile')" class="text-blue-400 hover:text-blue-300 transition-colors">
                                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="h-32">
                        <canvas id="volume-profile-chart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Right Column: Trade Flow & Metrics -->
            <div class="space-y-6">

                <!-- Trade Flow -->
                <div class="rounded-xl border border-slate-700 bg-slate-900/60 p-4">
                    <div class="flex items-center justify-between mb-4">
                        <div class="flex items-center space-x-2">
                            <h3 class="text-lg font-semibold text-slate-200">Trade Flow</h3>
                            <button onclick="showHelpModal('tradeFlow')" class="text-blue-400 hover:text-blue-300 transition-colors">
                                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"/>
                                </svg>
                            </button>
                        </div>
                        <div class="text-xs text-slate-500">Real-time</div>
                    </div>

                    <div id="trade-flow" class="space-y-1 h-64 overflow-y-auto scrollbar-thin">
                        <div class="text-center text-slate-400 py-8 text-sm">
                            Select symbol for trade flow
                        </div>
                    </div>
                </div>

                <!-- Market Metrics -->
                <div class="rounded-xl border border-slate-700 bg-slate-900/60 p-4">
                    <div class="flex items-center justify-between mb-4">
                        <div class="flex items-center space-x-2">
                            <h3 class="text-lg font-semibold text-slate-200">Live Metrics</h3>
                            <button onclick="showHelpModal('liveMetrics')" class="text-blue-400 hover:text-blue-300 transition-colors">
                                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div id="market-metrics" class="space-y-3 text-sm">
                        <div class="flex justify-between">
                            <span class="text-slate-400">Spread:</span>
                            <span class="font-mono text-slate-200" id="spread-value">-</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-slate-400">Spread %:</span>
                            <span class="font-mono text-slate-200" id="spread-percent">-</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-slate-400">Mid Price:</span>
                            <span class="font-mono text-slate-200" id="mid-price">-</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-slate-400">Volume (1m):</span>
                            <span class="font-mono text-slate-200" id="volume-1m">-</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-slate-400">Trades (1m):</span>
                            <span class="font-mono text-slate-200" id="trades-1m">-</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-slate-400">VWAP:</span>
                            <span class="font-mono text-slate-200" id="vwap">-</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Alert Configuration Panel (Hidden by default) -->
        <div id="alert-panel" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center">
            <div class="bg-slate-900 border border-slate-700 rounded-xl p-6 max-w-md w-full mx-4">
                <div class="flex items-center justify-between mb-4">
                    <h3 class="text-lg font-semibold text-slate-200">Alert Configuration</h3>
                    <button id="close-alerts" class="text-slate-400 hover:text-slate-200">‚úï</button>
                </div>

                <div class="space-y-4">
                    <div>
                        <label class="block text-sm text-slate-400 mb-1">Spread Alert (%)</label>
                        <input type="number" id="spread-alert" class="w-full bg-slate-800 border border-slate-600 rounded px-3 py-2 text-sm"
                               placeholder="0.5" step="0.1" min="0">
                    </div>

                    <div>
                        <label class="block text-sm text-slate-400 mb-1">Volume Spike (%)</label>
                        <input type="number" id="volume-alert" class="w-full bg-slate-800 border border-slate-600 rounded px-3 py-2 text-sm"
                               placeholder="200" step="50" min="0">
                    </div>

                    <div>
                        <label class="block text-sm text-slate-400 mb-1">Price Movement (%)</label>
                        <input type="number" id="price-alert" class="w-full bg-slate-800 border border-slate-600 rounded px-3 py-2 text-sm"
                               placeholder="2.0" step="0.5" min="0">
                    </div>

                    <div class="flex items-center">
                        <input type="checkbox" id="sound-alerts" class="mr-2">
                        <label class="text-sm text-slate-400">Enable sound alerts</label>
                    </div>

                    <div class="flex space-x-2 pt-2">
                        <button id="save-alerts" class="flex-1 bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded text-sm transition-colors">
                            Save Settings
                        </button>
                        <button id="test-alert" class="px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded text-sm transition-colors">
                            Test
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Data Status -->
        <div class="rounded-xl border border-slate-700 bg-slate-900/60 p-4">
            <div class="flex items-center justify-between mb-4">
                <h3 class="text-lg font-semibold text-slate-200">System Status</h3>
                <div class="flex space-x-2">
                    <button id="alerts-config" class="px-3 py-1 bg-orange-600 hover:bg-orange-700 rounded text-sm transition-colors">
                        üîî Alerts
                    </button>
                    <button id="export-data" class="px-3 py-1 bg-green-600 hover:bg-green-700 rounded text-sm transition-colors">
                        üìä Export
                    </button>
                    <button id="refresh-data" class="px-3 py-1 bg-blue-600 hover:bg-blue-700 rounded text-sm transition-colors">
                        üîÑ Refresh
                    </button>
                </div>
            </div>

            <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                <div class="text-center">
                    <div class="text-slate-400">WebSocket</div>
                    <div class="font-semibold" id="ws-status">
                        <span class="text-green-400">‚óè</span> Connected
                    </div>
                </div>
                <div class="text-center">
                    <div class="text-slate-400">Data Lag</div>
                    <div class="font-semibold text-slate-200" id="data-lag">< 50ms</div>
                </div>
                <div class="text-center">
                    <div class="text-slate-400">Events/min</div>
                    <div class="font-semibold text-slate-200" id="events-per-min">-</div>
                </div>
                <div class="text-center">
                    <div class="text-slate-400">Memory Usage</div>
                    <div class="font-semibold text-slate-200" id="memory-usage">-</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let currentSymbol = null;
        let charts = {};
        let chartType = 'line'; // 'line' or 'candlestick'
        let updateIntervals = {};
        let lastUpdateTimes = {};
        let performanceMetrics = {
            apiCalls: 0,
            dataProcessed: 0,
            avgLatency: 0,
            memoryUsage: 0
        };

        // Performance optimization settings
        const UPDATE_THROTTLE = {
            orderbook: 2000,
            trades: 3000,
            candles: 15000,
            metrics: 5000,
            health: 10000
        };

        // Alert system
        let alertSettings = {
            spreadThreshold: 0.5,
            volumeThreshold: 200,
            priceThreshold: 2.0,
            soundEnabled: true
        };

        let lastAlertTimes = {};
        const ALERT_COOLDOWN = 30000; // 30 seconds between same type alerts

        // Initialize page
        document.addEventListener('DOMContentLoaded', async function() {
            loadAlertSettings();
            await loadSymbols();
            await loadSystemStats();
            initializeCharts();
            startRealTimeUpdates();
        });

        // Load available symbols
        async function loadSymbols() {
            const selector = document.getElementById('symbol-selector');
            selector.innerHTML = '<option value="">Select Symbol...</option>';

            // Hardcoded symbols as primary fallback
            const defaultSymbols = [
                'BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'ADAUSDT', 'SOLUSDT',
                'XRPUSDT', 'DOTUSDT', 'AVAXUSDT', 'LINKUSDT', 'MATICUSDT',
                'ATOMUSDT', 'LTCUSDT', 'UNIUSDT', 'FILUSDT', 'TRXUSDT',
                'ETCUSDT', 'XLMUSDT', 'BCHUSDT', 'ALGOUSDT', 'VETUSDT'
            ];

            let symbolsLoaded = false;

            try {
                console.log('üîç Trying primary API: /api/microstructure/symbols');
                const response = await fetch('/api/microstructure/symbols');

                if (response.ok) {
                    const data = await response.json();
                    console.log('üìä Primary API data:', data);

                    // Check different response formats
                    let symbols = null;
                    if (data.success && data.data) {
                        symbols = data.data;
                    } else if (data.ok && data.symbols) {
                        symbols = data.symbols;
                    } else if (Array.isArray(data)) {
                        symbols = data;
                    }

                    if (symbols && symbols.length > 0) {
                        console.log(`‚úÖ Loaded ${symbols.length} symbols from primary API`);
                        symbols.forEach(symbol => {
                            const option = document.createElement('option');
                            // Handle both string and object formats
                            const symbolName = typeof symbol === 'string' ? symbol : (symbol.symbol || symbol.name || symbol);
                            const status = typeof symbol === 'string' ? 'active' : (symbol.status || 'active');

                            // Ensure we have a valid symbol name
                            if (symbolName && typeof symbolName === 'string') {
                                option.value = symbolName;
                                option.textContent = `${symbolName} (${status})`;
                                selector.appendChild(option);
                            } else {
                                console.warn('Invalid symbol format:', symbol);
                            }
                        });

                        document.getElementById('active-symbols-count').textContent = symbols.length;
                        document.getElementById('symbols-status').textContent = `${symbols.filter(s => {
                            const status = typeof s === 'string' ? 'active' : (s.status || 'active');
                            return status === 'active';
                        }).length} active`;
                        symbolsLoaded = true;
                    }
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Primary API failed:', error);
            }

            if (!symbolsLoaded) {
                try {
                    console.log('üîÑ Trying fallback API: /monitor/api/symbols');
                    const fallbackResponse = await fetch('/monitor/api/symbols');

                    if (fallbackResponse.ok) {
                        const fallbackData = await fallbackResponse.json();
                        console.log('üìã Fallback API data:', fallbackData);

                        if (fallbackData.ok && fallbackData.symbols && fallbackData.symbols.length > 0) {
                            console.log(`‚úÖ Loaded ${fallbackData.symbols.length} symbols from fallback API`);
                            fallbackData.symbols.forEach(symbol => {
                                const option = document.createElement('option');
                                option.value = symbol;
                                option.textContent = symbol;
                                selector.appendChild(option);
                            });

                            document.getElementById('active-symbols-count').textContent = fallbackData.symbols.length;
                            document.getElementById('symbols-status').textContent = `${fallbackData.symbols.length} available`;
                            symbolsLoaded = true;
                        }
                    }
                } catch (fallbackError) {
                    console.warn('‚ö†Ô∏è Fallback API failed:', fallbackError);
                }
            }

            if (!symbolsLoaded) {
                try {
                    console.log('üîÑ Trying universe API: /monitor/api/universe');
                    const universeResponse = await fetch('/monitor/api/universe');

                    if (universeResponse.ok) {
                        const universeData = await universeResponse.json();
                        console.log('üåå Universe API data:', universeData);

                        if (universeData.ok && universeData.symbols && universeData.symbols.length > 0) {
                            console.log(`‚úÖ Loaded ${universeData.symbols.length} symbols from universe API`);
                            universeData.symbols.forEach(symbolData => {
                                const option = document.createElement('option');
                                const symbol = typeof symbolData === 'string' ? symbolData : symbolData.symbol;
                                option.value = symbol;
                                option.textContent = symbol;
                                selector.appendChild(option);
                            });

                            document.getElementById('active-symbols-count').textContent = universeData.symbols.length;
                            document.getElementById('symbols-status').textContent = `${universeData.symbols.length} from universe`;
                            symbolsLoaded = true;
                        }
                    }
                } catch (universeError) {
                    console.warn('‚ö†Ô∏è Universe API failed:', universeError);
                }
            }

            // Final fallback: use hardcoded symbols
            if (!symbolsLoaded) {
                console.log('üîß Using hardcoded symbols as final fallback');
                defaultSymbols.forEach(symbol => {
                    const option = document.createElement('option');
                    option.value = symbol;
                    option.textContent = symbol;
                    selector.appendChild(option);
                });

                document.getElementById('active-symbols-count').textContent = defaultSymbols.length;
                document.getElementById('symbols-status').textContent = `${defaultSymbols.length} default symbols`;
                console.log(`‚úÖ Loaded ${defaultSymbols.length} hardcoded symbols`);
            }
        }

        // Load system statistics
        async function loadSystemStats() {
            try {
                console.log('üè• Loading system stats...');

                // Try microstructure health endpoint first
                try {
                    const response = await fetch('/api/health');
                    const data = await response.json();
                    console.log('ü©∫ Health data:', data);

                    if (data.success) {
                        document.getElementById('system-health').textContent = 'Good';
                        document.getElementById('health-details').textContent = 'All systems operational';
                    }
                } catch (healthError) {
                    console.warn('‚ö†Ô∏è Health API failed, using fallback...');
                    // Fallback to monitor storage API
                    try {
                        const storageResponse = await fetch('/monitor/api/storage');
                        const storageData = await storageResponse.json();
                        if (storageData.ok) {
                            document.getElementById('system-health').textContent = 'Good';
                            document.getElementById('health-details').textContent = 'Storage system active';
                        }
                    } catch (fallbackError) {
                        console.error('‚ùå All health checks failed');
                        document.getElementById('system-health').textContent = 'Warning';
                        document.getElementById('health-details').textContent = 'Limited connectivity';
                    }
                }
            } catch (error) {
                console.error('üí• Error loading system stats:', error);
                document.getElementById('system-health').textContent = 'Error';
                document.getElementById('health-details').textContent = 'Cannot connect to API';
            }
        }

        // Symbol selection handler
        document.getElementById('symbol-selector').addEventListener('change', function(e) {
            const symbol = e.target.value;
            if (symbol) {
                selectSymbol(symbol);
            } else {
                clearSymbolData();
            }
        });

        // Throttle function to prevent excessive API calls
        function shouldUpdate(type) {
            const now = Date.now();
            const lastUpdate = lastUpdateTimes[type] || 0;
            const throttleTime = UPDATE_THROTTLE[type] || 5000;

            if (now - lastUpdate >= throttleTime) {
                lastUpdateTimes[type] = now;
                return true;
            }
            return false;
        }

        // Performance monitoring
        function trackPerformance(operation, startTime) {
            const duration = Date.now() - startTime;
            performanceMetrics.apiCalls++;
            performanceMetrics.avgLatency = (performanceMetrics.avgLatency + duration) / 2;

            // Update performance display if elements exist
            const apiCallsElement = document.getElementById('api-calls-count');
            const latencyElement = document.getElementById('avg-latency');
            if (apiCallsElement) apiCallsElement.textContent = performanceMetrics.apiCalls;
            if (latencyElement) latencyElement.textContent = Math.round(performanceMetrics.avgLatency) + 'ms';
        }

        // Select symbol and load its data
        async function selectSymbol(symbol) {
            currentSymbol = symbol;

            // Clear existing intervals and cleanup
            Object.values(updateIntervals).forEach(interval => clearInterval(interval));
            updateIntervals = {};
            lastUpdateTimes = {};

            // Load symbol data
            await loadSymbolStats(symbol);
            await loadOrderbook(symbol);
            await loadTradeFlow(symbol);
            await loadMicroCandles(symbol);

            // Start real-time updates for this symbol
            startSymbolUpdates(symbol);
        }

        // Clear symbol data
        function clearSymbolData() {
            currentSymbol = null;
            Object.values(updateIntervals).forEach(interval => clearInterval(interval));
            updateIntervals = {};

            document.getElementById('symbol-stats').innerHTML = '<div class="text-center text-slate-400 py-8">Select a symbol to view details</div>';
            document.getElementById('orderbook-display').innerHTML = '<div class="text-center text-slate-400 py-8">Select symbol for orderbook</div>';
            document.getElementById('trade-flow').innerHTML = '<div class="text-center text-slate-400 py-8 text-sm">Select symbol for trade flow</div>';
        }

        // Load symbol statistics
        async function loadSymbolStats(symbol) {
            try {
                console.log(`üìä Loading stats for symbol: ${symbol}`);

                // Try microstructure API first
                try {
                    const response = await fetch(`/api/symbol/${symbol}/micro`);
                    const data = await response.json();
                    console.log('üìà Micro data:', data);

                    if (data.success && data.data) {
                        const stats = data.data;
                        document.getElementById('symbol-stats').innerHTML = `
                            <div class="space-y-2">
                                <div class="flex justify-between text-sm">
                                    <span class="text-slate-400">Symbol:</span>
                                    <span class="font-mono text-slate-100 font-semibold">${symbol}</span>
                                </div>
                                <div class="flex justify-between text-sm">
                                    <span class="text-slate-400">Status:</span>
                                    <span class="text-green-400">${stats.status || 'Active'}</span>
                                </div>
                                <div class="flex justify-between text-sm">
                                    <span class="text-slate-400">Last Update:</span>
                                    <span class="text-slate-300">${new Date(stats.lastUpdate || Date.now()).toLocaleTimeString()}</span>
                                </div>
                                <div class="flex justify-between text-sm">
                                    <span class="text-slate-400">Events Today:</span>
                                    <span class="text-slate-300">${stats.eventsCount || '-'}</span>
                                </div>
                            </div>
                        `;
                        return;
                    }
                } catch (microError) {
                    console.warn('‚ö†Ô∏è Micro API failed, using fallback stats...');
                }

                // Fallback: show basic symbol info
                document.getElementById('symbol-stats').innerHTML = `
                    <div class="space-y-2">
                        <div class="flex justify-between text-sm">
                            <span class="text-slate-400">Symbol:</span>
                            <span class="font-mono text-slate-100 font-semibold">${symbol}</span>
                        </div>
                        <div class="flex justify-between text-sm">
                            <span class="text-slate-400">Status:</span>
                            <span class="text-green-400">Active</span>
                        </div>
                        <div class="flex justify-between text-sm">
                            <span class="text-slate-400">Last Update:</span>
                            <span class="text-slate-300">${new Date().toLocaleTimeString()}</span>
                        </div>
                        <div class="flex justify-between text-sm">
                            <span class="text-slate-400">Data Source:</span>
                            <span class="text-slate-300">Live Stream</span>
                        </div>
                    </div>
                `;
            } catch (error) {
                console.error('üí• Error loading symbol stats:', error);
                document.getElementById('symbol-stats').innerHTML = `
                    <div class="text-center text-red-400 py-4">
                        Error loading symbol data
                    </div>
                `;
            }
        }

        // Load orderbook data
        async function loadOrderbook(symbol) {
            try {
                console.log(`üìñ Loading orderbook for: ${symbol}`);

                try {
                    const response = await fetch(`/api/symbol/${symbol}/orderbook`);
                    const data = await response.json();

                    if (data.success && data.data && data.data.bids && data.data.bids.length > 0) {
                        console.log(`‚úÖ Got real orderbook from API for ${symbol}`);
                        renderOrderbook(data.data);
                        return;
                    }
                } catch (orderbookError) {
                    console.warn('‚ö†Ô∏è Orderbook API failed:', orderbookError);
                }

                // Fallback: Try Bybit REST API directly
                console.log(`üîÑ Trying Bybit REST API for ${symbol}...`);
                try {
                    const bybitResponse = await fetch(`https://api.bybit.com/v5/market/orderbook?category=linear&symbol=${symbol}&limit=25`);
                    const bybitData = await bybitResponse.json();

                    if (bybitData.retCode === 0 && bybitData.result) {
                        const { b: bids, a: asks, ts: timestamp } = bybitData.result;

                        console.log(`‚úÖ Got real orderbook from Bybit for ${symbol}`, {
                            bids: bids?.length || 0,
                            asks: asks?.length || 0,
                            bestBid: bids?.[0]?.[0],
                            bestAsk: asks?.[0]?.[0]
                        });

                        const orderbook = {
                            symbol,
                            bids: bids || [],
                            asks: asks || [],
                            timestamp: parseInt(timestamp) || Date.now()
                        };

                        renderOrderbook(orderbook);
                        return;
                    }
                } catch (bybitError) {
                    console.error('üí• Bybit API failed:', bybitError);
                }

                // Last resort: show error
                document.getElementById('orderbook-display').innerHTML = '<div class="text-center text-yellow-400 py-4">No orderbook data available</div>';

            } catch (error) {
                console.error('üí• Error loading orderbook:', error);
                document.getElementById('orderbook-display').innerHTML = '<div class="text-center text-red-400 py-4">Error loading orderbook</div>';
            }
        }

        // Generate simulated orderbook for demo
        function generateSimulatedOrderbook(symbol) {
            const basePrice = Math.random() * 100 + 20; // Random price between 20-120
            const spread = basePrice * 0.001; // 0.1% spread

            const bids = [];
            const asks = [];

            // Generate 10 bid levels
            for (let i = 0; i < 10; i++) {
                const price = basePrice - (i * spread * 0.1);
                const size = Math.random() * 1000 + 100;
                bids.push([price.toFixed(4), size.toFixed(2)]);
            }

            // Generate 10 ask levels
            for (let i = 0; i < 10; i++) {
                const price = basePrice + spread + (i * spread * 0.1);
                const size = Math.random() * 1000 + 100;
                asks.push([price.toFixed(4), size.toFixed(2)]);
            }

            return {
                symbol: symbol,
                bids: bids,
                asks: asks,
                timestamp: Date.now()
            };
        }

        // Render orderbook
        function renderOrderbook(orderbook) {
            const display = document.getElementById('orderbook-display');
            const timestamp = document.getElementById('orderbook-timestamp');

            if (!orderbook.bids || !orderbook.asks) {
                display.innerHTML = '<div class="text-center text-slate-400 py-4">No orderbook data available</div>';
                return;
            }

            timestamp.textContent = new Date(orderbook.timestamp || Date.now()).toLocaleTimeString();

            const bids = orderbook.bids.slice(0, 10);
            const asks = orderbook.asks.slice(0, 10).reverse();

            // UPDATE CURRENT PRICE DISPLAY
            const bestBid = bids.length > 0 ? parseFloat(bids[0][0]) : 0;
            const bestAsk = asks.length > 0 ? parseFloat(asks[asks.length - 1][0]) : 0;
            const midPrice = (bestBid + bestAsk) / 2;
            const spread = bestAsk - bestBid;

            document.getElementById('current-price').textContent = midPrice.toFixed(4);
            document.getElementById('best-bid').textContent = bestBid.toFixed(4);
            document.getElementById('best-ask').textContent = bestAsk.toFixed(4);
            document.getElementById('current-spread').textContent = spread.toFixed(4);

            // UPDATE LIVE METRICS WITH REAL DATA
            updateLiveMetricsFromOrderbook({
                bestBid,
                bestAsk,
                midPrice,
                spread
            });

            let html = `
                <div class="grid grid-cols-3 gap-2 text-xs font-semibold text-slate-400 mb-2 px-2">
                    <div>Price</div>
                    <div class="text-right">Size</div>
                    <div class="text-right">Total</div>
                </div>
            `;

            // Asks (sells) - red
            asks.forEach(ask => {
                html += `
                    <div class="grid grid-cols-3 gap-2 text-xs py-0.5 hover:bg-slate-800 px-2">
                        <div class="price-down font-mono">${parseFloat(ask[0]).toFixed(4)}</div>
                        <div class="text-right font-mono text-slate-300">${parseFloat(ask[1]).toFixed(2)}</div>
                        <div class="text-right font-mono text-slate-400">${(parseFloat(ask[0]) * parseFloat(ask[1])).toFixed(2)}</div>
                    </div>
                `;
            });

            // Spread
            if (bids.length > 0 && asks.length > 0) {
                const spread = parseFloat(asks[asks.length - 1][0]) - parseFloat(bids[0][0]);
                html += `
                    <div class="border-t border-b border-slate-600 py-1 my-1">
                        <div class="text-center text-xs text-slate-400">
                            Spread: <span class="text-slate-300 font-mono">${spread.toFixed(4)}</span>
                        </div>
                    </div>
                `;
            }

            // Bids (buys) - green
            bids.forEach(bid => {
                html += `
                    <div class="grid grid-cols-3 gap-2 text-xs py-0.5 hover:bg-slate-800 px-2">
                        <div class="price-up font-mono">${parseFloat(bid[0]).toFixed(4)}</div>
                        <div class="text-right font-mono text-slate-300">${parseFloat(bid[1]).toFixed(2)}</div>
                        <div class="text-right font-mono text-slate-400">${(parseFloat(bid[0]) * parseFloat(bid[1])).toFixed(2)}</div>
                    </div>
                `;
            });

            display.innerHTML = html;
        }

        // Load trade flow
        async function loadTradeFlow(symbol) {
            try {
                console.log(`üí± Loading trade flow for: ${symbol}`);

                try {
                    const response = await fetch(`/api/symbol/${symbol}/trades?limit=50`);
                    const data = await response.json();

                    if (data.success && data.data) {
                        renderTradeFlow(data.data);
                        return;
                    }
                } catch (tradeError) {
                    console.warn('‚ö†Ô∏è Trade API failed, generating simulation...');
                }

                // Fallback: simulate trade flow
                const simulatedTrades = generateSimulatedTrades(symbol, 20);
                renderTradeFlow(simulatedTrades);

            } catch (error) {
                console.error('üí• Error loading trade flow:', error);
                document.getElementById('trade-flow').innerHTML = '<div class="text-center text-red-400 py-4 text-sm">Error loading trades</div>';
            }
        }

        // Generate simulated trades
        function generateSimulatedTrades(symbol, count) {
            const trades = [];
            const basePrice = Math.random() * 100 + 20;

            for (let i = 0; i < count; i++) {
                const priceVariation = (Math.random() - 0.5) * 0.02; // ¬±1% variation
                const price = basePrice * (1 + priceVariation);
                const size = Math.random() * 100 + 10;
                const side = Math.random() > 0.5 ? 'Buy' : 'Sell';
                const timestamp = Date.now() - (i * 1000 * Math.random() * 60); // Random recent times

                trades.push({
                    symbol: symbol,
                    price: price.toFixed(4),
                    size: size.toFixed(2),
                    side: side,
                    timestamp: timestamp
                });
            }

            return trades.sort((a, b) => b.timestamp - a.timestamp); // Most recent first
        }

        // Render trade flow
        function renderTradeFlow(trades) {
            const container = document.getElementById('trade-flow');

            if (!trades || trades.length === 0) {
                container.innerHTML = '<div class="text-center text-slate-400 py-4 text-sm">No recent trades</div>';
                return;
            }

            let html = '';
            trades.slice(0, 30).forEach(trade => {
                const time = new Date(trade.timestamp || Date.now()).toLocaleTimeString();
                const side = trade.side === 'Buy' ? 'price-up' : 'price-down';
                const sideIcon = trade.side === 'Buy' ? '‚Üó' : '‚Üò';

                html += `
                    <div class="trade-flow-item flex justify-between items-center text-xs py-1 px-2 hover:bg-slate-800 rounded">
                        <div class="flex items-center space-x-2">
                            <span class="${side}">${sideIcon}</span>
                            <span class="font-mono text-slate-300">${parseFloat(trade.price).toFixed(4)}</span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <span class="font-mono text-slate-400">${parseFloat(trade.size).toFixed(2)}</span>
                            <span class="text-slate-500">${time.split(':').slice(1).join(':')}</span>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        // Load micro candles
        async function loadMicroCandles(symbol) {
            const timeframe = document.getElementById('timeframe-selector').value;

            try {
                console.log(`üïØÔ∏è Loading candles for ${symbol} (${timeframe})`);

                try {
                    // Use correct existing API endpoint: /api/symbol/:symbol/candles/:timeframe
                    const response = await fetch(`/api/symbol/${symbol}/candles/${timeframe}`);
                    const data = await response.json();

                    console.log('üìä Candles API response:', data);

                    // Check for both 'ok' (new format) and 'success' (old format)
                    if ((data.ok || data.success) && (data.candles || data.data)) {
                        const candles = data.candles || data.data;
                        console.log(`‚úÖ Loaded ${candles.length} candles for ${symbol}`);

                        if (candles.length > 0) {
                            updateCandleChart(candles);
                            return;
                        } else {
                            console.warn('‚ö†Ô∏è No candles available, using simulation');
                        }
                    }
                } catch (candleError) {
                    console.warn('‚ö†Ô∏è Candle API failed:', candleError);
                }

                // Fallback: simulate candle data
                console.log('üé≤ Generating simulated candles');
                const simulatedCandles = generateSimulatedCandles(symbol, timeframe, 50);
                updateCandleChart(simulatedCandles);

            } catch (error) {
                console.error('üí• Error loading micro candles:', error);
            }
        }

        // Generate simulated candles
        function generateSimulatedCandles(symbol, timeframe, count) {
            const candles = [];
            const basePrice = Math.random() * 100 + 20;
            const timeframeMs = parseTimeframe(timeframe);

            let currentPrice = basePrice;
            const now = Date.now();

            for (let i = count - 1; i >= 0; i--) {
                const timestamp = now - (i * timeframeMs);
                const variation = (Math.random() - 0.5) * 0.02; // ¬±1% variation
                const open = currentPrice;
                const close = currentPrice * (1 + variation);
                const high = Math.max(open, close) * (1 + Math.random() * 0.005);
                const low = Math.min(open, close) * (1 - Math.random() * 0.005);
                const volume = Math.random() * 1000 + 100;

                candles.push({
                    timestamp: timestamp,
                    open: open.toFixed(4),
                    high: high.toFixed(4),
                    low: low.toFixed(4),
                    close: close.toFixed(4),
                    volume: volume.toFixed(2)
                });

                currentPrice = close;
            }

            return candles;
        }

        // Enhanced timeframe handling
        const TIMEFRAME_CONFIG = {
            '1s': {
                ms: 1000,
                maxPoints: 300,
                updateRate: 1000,
                description: 'Ultra high-frequency: Perfect for scalping and tick analysis',
                aggregation: 'none'
            },
            '5s': {
                ms: 5000,
                maxPoints: 240,
                updateRate: 2000,
                description: 'High-frequency: Ideal for short-term momentum tracking',
                aggregation: 'simple'
            },
            '15s': {
                ms: 15000,
                maxPoints: 200,
                updateRate: 5000,
                description: 'Medium-frequency: Good balance between noise and signal',
                aggregation: 'weighted'
            },
            '30s': {
                ms: 30000,
                maxPoints: 160,
                updateRate: 10000,
                description: 'Low-frequency: Smoother trends, less market noise',
                aggregation: 'weighted'
            },
            '1m': {
                ms: 60000,
                maxPoints: 120,
                updateRate: 15000,
                description: 'Standard timeframe: Traditional minute-based analysis',
                aggregation: 'ohlc'
            },
            '5m': {
                ms: 300000,
                maxPoints: 100,
                updateRate: 30000,
                description: 'Smooth analysis: Reduces noise, shows clear patterns',
                aggregation: 'ohlc'
            },
            '15m': {
                ms: 900000,
                maxPoints: 80,
                updateRate: 60000,
                description: 'Trend analysis: Focus on medium-term price movements',
                aggregation: 'ohlc'
            }
        };

        // Parse timeframe to milliseconds (legacy support)
        function parseTimeframe(timeframe) {
            const config = TIMEFRAME_CONFIG[timeframe];
            if (config) return config.ms;

            const value = parseInt(timeframe);
            if (timeframe.includes('s')) return value * 1000;
            if (timeframe.includes('m')) return value * 60 * 1000;
            if (timeframe.includes('h')) return value * 60 * 60 * 1000;
            return 5000; // default 5 seconds
        }

        // Get timeframe configuration
        function getTimeframeConfig(timeframe) {
            return TIMEFRAME_CONFIG[timeframe] || TIMEFRAME_CONFIG['5s'];
        }

        // Data aggregation for different timeframes
        function aggregateCandles(candles, timeframe) {
            const config = getTimeframeConfig(timeframe);

            if (config.aggregation === 'none' || !candles || candles.length === 0) {
                return candles || [];
            }

            const aggregated = [];
            const bucketSize = config.ms;

            // Group candles by timeframe buckets
            const buckets = {};
            candles.forEach(candle => {
                // Support both timestamp and bucketStart fields
                const timestamp = new Date(candle.timestamp || candle.bucketStart).getTime();
                const bucketKey = Math.floor(timestamp / bucketSize) * bucketSize;

                if (!buckets[bucketKey]) {
                    buckets[bucketKey] = [];
                }
                buckets[bucketKey].push(candle);
            });

            // Aggregate each bucket
            Object.keys(buckets).sort().forEach(bucketKey => {
                const bucket = buckets[bucketKey];

                if (config.aggregation === 'ohlc') {
                    // OHLC aggregation - support both API formats
                    const firstCandle = bucket[0];
                    const lastCandle = bucket[bucket.length - 1];

                    aggregated.push({
                        timestamp: new Date(parseInt(bucketKey)),
                        open: firstCandle.open || firstCandle.price,
                        high: firstCandle.high || Math.max(...bucket.map(c => c.close || c.price)),
                        low: firstCandle.low || Math.min(...bucket.map(c => c.close || c.price)),
                        close: lastCandle.close || lastCandle.price,
                        volume: firstCandle.volume || bucket.reduce((sum, c) => sum + (c.volume || 0), 0),
                        price: lastCandle.close || lastCandle.price // For line chart compatibility
                    });
                } else if (config.aggregation === 'weighted') {
                    // Volume-weighted average - support both API formats
                    const totalVolume = bucket.reduce((sum, c) => sum + (c.volume || 1), 0);
                    const weightedPrice = bucket.reduce((sum, c) => sum + (c.close || c.price) * (c.volume || 1), 0) / totalVolume;

                    aggregated.push({
                        timestamp: new Date(parseInt(bucketKey)),
                        price: weightedPrice,
                        close: weightedPrice,  // Add close field
                        volume: totalVolume
                    });
                } else {
                    // Simple average - support both API formats (close from API, price from trades)
                    const avgPrice = bucket.reduce((sum, c) => sum + (c.close || c.price), 0) / bucket.length;

                    aggregated.push({
                        timestamp: new Date(parseInt(bucketKey)),
                        price: avgPrice,
                        close: avgPrice,  // Add close field for consistency
                        volume: bucket.reduce((sum, c) => sum + (c.volume || 0), 0)
                    });
                }
            });

            return aggregated.slice(-config.maxPoints);
        }

        // Destroy existing charts to prevent memory leaks
        function destroyCharts() {
            Object.keys(charts).forEach(key => {
                const chart = charts[key];
                if (chart && typeof chart.destroy === 'function') {
                    chart.destroy();
                }
                charts[key] = null;
            });
        }

        // Initialize charts with performance optimizations
        let chartsInitialized = false;

        function initializeCharts() {
            console.log('üé® Initializing charts...', {
                chartsInitialized,
                chartType,
                hasFinancialPlugin: typeof Chart.controllers.candlestick !== 'undefined'
            });

            // Only destroy if already initialized (prevent destroying on first load)
            if (chartsInitialized) {
                console.log('üîÑ Charts already initialized, destroying old charts...');
                destroyCharts();
            }
            chartsInitialized = true;

            const ctx = document.getElementById('micro-candles-chart');

            if (!ctx) {
                console.error('‚ùå Canvas element not found: micro-candles-chart');
                return;
            }

            console.log('‚úÖ Canvas found, creating chart...');

            // Force canvas to be visible (debug)
            ctx.style.display = 'block';
            ctx.style.visibility = 'visible';
            ctx.style.opacity = '1';
            console.log('üìê Canvas dimensions:', {
                width: ctx.width,
                height: ctx.height,
                clientWidth: ctx.clientWidth,
                clientHeight: ctx.clientHeight,
                offsetParent: ctx.offsetParent
            });

            charts.candles = new Chart(ctx, {
                type: chartType,
                data: {
                    datasets: [{
                        label: currentSymbol || 'Price',
                        data: [],
                        // Candlestick colors
                        color: {
                            up: '#10b981',
                            down: '#ef4444',
                            unchanged: '#6b7280'
                        },
                        borderColor: {
                            up: '#10b981',
                            down: '#ef4444',
                            unchanged: '#6b7280'
                        },
                        // Line chart fallback colors
                        borderColor: '#22c55e',  // Brighter green for line
                        borderWidth: 3,  // Thicker line
                        backgroundColor: 'rgba(34, 197, 94, 0.1)',  // Lighter fill
                        pointBackgroundColor: '#22c55e',
                        pointBorderColor: '#fff',
                        pointBorderWidth: 2,
                        pointRadius: 2,  // Small visible points
                        pointHoverRadius: 8,  // Larger on hover
                        fill: true,
                        tension: 0.3  // Slightly less curved for clarity
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    animation: {
                        duration: 300,
                        easing: 'easeInOutQuad'
                    },
                    parsing: false,
                    normalized: true,
                    datasets: {
                        line: {
                            pointRadius: 0,
                            pointHoverRadius: 3
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            grid: {
                                color: 'rgba(55, 65, 81, 0.5)',
                                borderColor: '#4b5563',
                                tickColor: '#4b5563',
                                drawBorder: true,
                                drawTicks: true,
                                lineWidth: 1
                            },
                            ticks: {
                                color: '#9ca3af',
                                maxTicksLimit: 8,
                                font: {
                                    size: 11
                                },
                                callback: function(value) {
                                    const date = new Date(value);
                                    return date.toLocaleTimeString('en-US', {
                                        hour: '2-digit',
                                        minute: '2-digit',
                                        second: '2-digit',
                                        hour12: false
                                    });
                                }
                            }
                        },
                        y: {
                            beginAtZero: false,
                            grace: '5%',
                            position: 'right',  // Price on right side (trading style)
                            grid: {
                                color: 'rgba(55, 65, 81, 0.3)',
                                borderColor: '#4b5563',
                                tickColor: '#4b5563',
                                drawBorder: true,
                                lineWidth: 1
                            },
                            ticks: {
                                color: '#9ca3af',
                                maxTicksLimit: 10,
                                font: {
                                    size: 11,
                                    weight: '500'
                                },
                                callback: function(value) {
                                    return parseFloat(value).toFixed(4);
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            enabled: true,
                            mode: 'index',
                            intersect: false,
                            backgroundColor: 'rgba(17, 24, 39, 0.95)',
                            borderColor: '#10b981',
                            borderWidth: 2,
                            titleColor: '#10b981',
                            bodyColor: '#f3f4f6',
                            padding: 12,
                            displayColors: false,
                            callbacks: {
                                label: function(context) {
                                    const dataPoint = context.raw;

                                    // Check if candlestick data (has o, h, l, c properties)
                                    if (dataPoint && typeof dataPoint === 'object' && 'o' in dataPoint) {
                                        return [
                                            `Open: ${parseFloat(dataPoint.o).toFixed(4)}`,
                                            `High: ${parseFloat(dataPoint.h).toFixed(4)}`,
                                            `Low: ${parseFloat(dataPoint.l).toFixed(4)}`,
                                            `Close: ${parseFloat(dataPoint.c).toFixed(4)}`
                                        ];
                                    }

                                    // Line chart fallback
                                    return `Price: ${context.parsed.y.toFixed(4)}`;
                                },
                                title: function(context) {
                                    const dataPoint = context[0].raw;
                                    const timestamp = dataPoint?.x || context[0].parsed.x;
                                    const date = new Date(timestamp);
                                    return date.toLocaleString('en-US', {
                                        hour: '2-digit',
                                        minute: '2-digit',
                                        second: '2-digit',
                                        hour12: false
                                    });
                                }
                            }
                        }
                    },
                    onHover: (event, activeElements) => {
                        event.native.target.style.cursor = activeElements.length > 0 ? 'crosshair' : 'default';
                    }
                }
            });

            console.log('‚úÖ Candles chart created:', {
                hasChart: !!charts.candles,
                chartType: charts.candles?.config?.type,
                datasetsCount: charts.candles?.data?.datasets?.length
            });

            // Volume profile chart with optimizations
            const volumeCtx = document.getElementById('volume-profile-chart');
            charts.volume = new Chart(volumeCtx, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Volume',
                        data: [],
                        backgroundColor: 'rgba(16, 185, 129, 0.7)',
                        borderColor: '#10b981',
                        borderWidth: 0,
                        barPercentage: 0.95,
                        categoryPercentage: 0.95
                    }]
                },
                options: {
                    indexAxis: 'y',  // Horizontal bars
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    animation: {
                        duration: 200,
                        easing: 'easeOutQuart'
                    },
                    scales: {
                        x: {
                            grid: {
                                color: 'rgba(55, 65, 81, 0.3)',
                                display: true
                            },
                            ticks: {
                                color: '#9ca3af',
                                maxTicksLimit: 5,
                                font: { size: 10 },
                                callback: function(value) {
                                    return value >= 1000 ? (value/1000).toFixed(1) + 'K' : value.toFixed(0);
                                }
                            }
                        },
                        y: {
                            grid: {
                                color: 'rgba(55, 65, 81, 0.3)',
                                display: false
                            },
                            ticks: {
                                color: '#9ca3af',
                                maxTicksLimit: 8,
                                font: { size: 10 },
                                callback: function(value) {
                                    return parseFloat(value).toFixed(4);
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            enabled: true,
                            mode: 'index',
                            intersect: false,
                            backgroundColor: 'rgba(17, 24, 39, 0.95)',
                            borderColor: '#10b981',
                            borderWidth: 1,
                            callbacks: {
                                label: function(context) {
                                    const value = context.parsed.y;
                                    return `Volume: ${value >= 1000 ? (value/1000).toFixed(1) + 'K' : value.toFixed(0)}`;
                                }
                            }
                        }
                    }
                }
            });

            console.log('‚úÖ Candle chart initialized:', !!charts.candles);
            console.log('‚úÖ Volume chart initialized:', !!charts.volume);
        }

        // Update candle chart with aggregation support
        function updateCandleChart(candles) {
            console.log('üìä updateCandleChart called with:', {
                hasChart: !!charts.candles,
                chartDestroyed: charts.candles?.$context === undefined,
                candlesCount: candles?.length || 0,
                firstCandle: candles?.[0],
                lastCandle: candles?.[candles?.length - 1]
            });

            if (!charts.candles) {
                console.error('‚ùå Charts.candles is null/undefined!');
                console.log('Available charts:', Object.keys(charts));
                return;
            }

            // Check if chart was destroyed
            if (!charts.candles.ctx || charts.candles.ctx.canvas === null) {
                console.error('‚ùå Chart was destroyed! Canvas is null.');
                return;
            }

            if (!candles || candles.length === 0) {
                console.warn('‚ö†Ô∏è No candles to display');
                return;
            }

            console.log('üïØÔ∏è RAW candles from API:', {
                count: candles.length,
                first3: candles.slice(0, 3),
                closePrices: candles.map(c => c.close || c.price)
            });

            const timeframe = document.getElementById('timeframe-selector').value;
            const aggregatedCandles = aggregateCandles(candles, timeframe);

            console.log('üìà Aggregated candles:', {
                timeframe,
                count: aggregatedCandles.length,
                sample: aggregatedCandles.slice(0, 3),
                allClosePrices: aggregatedCandles.map(c => c.close || c.price)
            });

            // Prepare data based on chart type
            let data;
            if (chartType === 'candlestick') {
                // Candlestick format: { x, o, h, l, c }
                data = aggregatedCandles.map(candle => ({
                    x: new Date(candle.timestamp || candle.bucketStart).getTime(),
                    o: parseFloat(candle.open),
                    h: parseFloat(candle.high),
                    l: parseFloat(candle.low),
                    c: parseFloat(candle.close)
                }));

                console.log('üïØÔ∏è Candlestick data:', {
                    pointsCount: data.length,
                    firstCandle: data[0],
                    lastCandle: data[data.length - 1]
                });
            } else {
                // Line chart format: { x, y }
                data = aggregatedCandles.map(candle => ({
                    x: new Date(candle.timestamp || candle.bucketStart).getTime(),
                    y: parseFloat(candle.close || candle.price)
                }));

                console.log('üìà Line data:', {
                    pointsCount: data.length,
                    priceRange: {
                        min: Math.min(...data.map(d => d.y)),
                        max: Math.max(...data.map(d => d.y))
                    }
                });
            }

            // Update chart with performance optimization
            charts.candles.data.datasets[0].data = data;

            // Force chart update without animation (more reliable)
            charts.candles.update('none');

            console.log('‚úÖ Chart updated successfully', {
                chartVisible: charts.candles.ctx.canvas.offsetParent !== null,
                canvasDisplay: window.getComputedStyle(charts.candles.ctx.canvas).display,
                dataPoints: charts.candles.data.datasets[0].data.length
            });

            // Update volume chart with same data
            updateVolumeChart(aggregatedCandles);
        }

        // Update volume chart
        function updateVolumeChart(candles) {
            if (!charts.volume || !candles || candles.length === 0) {
                return;
            }

            // Create volume profile - group by price levels
            const priceStep = 0.001; // Price bucket size
            const volumeByPrice = {};

            candles.forEach(candle => {
                const price = parseFloat(candle.close || candle.price);
                const volume = parseFloat(candle.volume || 0);
                const priceLevel = (Math.round(price / priceStep) * priceStep).toFixed(4);

                if (!volumeByPrice[priceLevel]) {
                    volumeByPrice[priceLevel] = 0;
                }
                volumeByPrice[priceLevel] += volume;
            });

            // Sort by price and prepare chart data
            const sortedPrices = Object.keys(volumeByPrice).sort((a, b) => parseFloat(a) - parseFloat(b));
            const volumes = sortedPrices.map(price => volumeByPrice[price]);

            // Update chart
            charts.volume.data.labels = sortedPrices;
            charts.volume.data.datasets[0].data = volumes;
            charts.volume.update('none');

            console.log('üìä Volume chart updated:', {
                priceLevels: sortedPrices.length,
                totalVolume: volumes.reduce((sum, v) => sum + v, 0),
                maxVolume: Math.max(...volumes)
            });
        }

        // Start real-time updates
        function startRealTimeUpdates() {
            // Global stats update with performance tracking
            updateIntervals.global = setInterval(async () => {
                if (shouldUpdate('health')) {
                    const startTime = Date.now();
                    try {
                        await loadSystemStats();

                        // Fetch REAL stats from engine (same endpoint as main dashboard)
                        const healthResponse = await fetch('http://5.223.76.141:8090/api/microstructure/health');
                        const healthData = await healthResponse.json();

                        if (healthData.ok) {
                            const health = healthData.health;
                            const symbols = healthData.symbols || [];

                            // Calculate events per second from trade counts
                            const totalTrades = symbols.reduce((sum, s) => sum + (s.tradesCount || 0), 0);
                            const eventsPerSecond = Math.floor(totalTrades / 60);

                            // Update with REAL data
                            document.getElementById('data-rate').textContent = eventsPerSecond + ' evt/s';
                            document.getElementById('events-per-min').textContent = (eventsPerSecond * 60).toLocaleString();

                            // Update active symbols count
                            const currentCount = parseInt(document.getElementById('active-symbols-count').textContent) || 0;
                            if (currentCount === 0 || Math.abs(currentCount - health.activeSymbols) > 5) {
                                document.getElementById('active-symbols-count').textContent = health.activeSymbols;
                            }

                            // Memory tracking (estimated from process)
                            const memoryMB = Math.round(process.memoryUsage ? process.memoryUsage().heapUsed / 1024 / 1024 : 0);
                            document.getElementById('storage-used').textContent = memoryMB + ' MB';
                            document.getElementById('memory-usage').textContent = memoryMB + ' MB';
                            performanceMetrics.memoryUsage = memoryMB;
                        }

                        trackPerformance('systemStats', startTime);

                    } catch (error) {
                        console.error('System stats error:', error);
                    }
                }
            }, 1000);
        }

        // Start symbol-specific updates with throttling
        function startSymbolUpdates(symbol) {
            // Consolidated update function with throttling
            const updateSymbolData = async () => {
                try {
                    const promises = [];

                    // Throttled updates
                    if (shouldUpdate('orderbook')) {
                        promises.push(loadOrderbook(symbol).catch(console.warn));
                    }

                    if (shouldUpdate('trades')) {
                        promises.push(loadTradeFlow(symbol).catch(console.warn));
                    }

                    if (shouldUpdate('candles')) {
                        promises.push(loadMicroCandles(symbol).catch(console.warn));
                    }

                    if (shouldUpdate('metrics')) {
                        promises.push(Promise.resolve().then(() => updateLiveMetrics(symbol)));
                    }

                    // Execute all updates concurrently
                    await Promise.allSettled(promises);

                } catch (error) {
                    console.error('Update error:', error);
                }
            };

            // Single interval for all symbol updates (more efficient)
            updateIntervals.symbolData = setInterval(updateSymbolData, 1000);

            // Initial load
            updateSymbolData();
        }

        // Update live metrics from real orderbook data
        function updateLiveMetricsFromOrderbook(orderbookData) {
            const { bestBid, bestAsk, midPrice, spread } = orderbookData;
            const spreadPercent = (spread / midPrice) * 100;

            document.getElementById('spread-value').textContent = spread.toFixed(4);
            document.getElementById('spread-percent').textContent = spreadPercent.toFixed(3) + '%';
            document.getElementById('mid-price').textContent = midPrice.toFixed(4);

            // Keep volume/trades/vwap as simulated for now (until we have real trade data)
            const volume = Math.floor(Math.random() * 10000 + 5000);
            document.getElementById('volume-1m').textContent = volume.toLocaleString();
            document.getElementById('trades-1m').textContent = Math.floor(Math.random() * 500 + 100);
            document.getElementById('vwap').textContent = (midPrice * (1 + (Math.random() - 0.5) * 0.001)).toFixed(4);

            // Note: checkAlerts removed - will be added back when we have symbol context
        }

        // Enhanced timeframe selector with info
        document.getElementById('timeframe-selector').addEventListener('change', function() {
            const timeframe = this.value;
            const config = getTimeframeConfig(timeframe);

            // Update chart immediately if symbol is selected
            if (currentSymbol) {
                loadMicroCandles(currentSymbol);
            }

            // Show brief feedback
            const selector = this;
            const originalBg = selector.style.backgroundColor;
            selector.style.backgroundColor = '#059669';
            setTimeout(() => {
                selector.style.backgroundColor = originalBg;
            }, 300);
        });

        // Timeframe info tooltip
        document.getElementById('timeframe-info').addEventListener('click', function() {
            const timeframe = document.getElementById('timeframe-selector').value;
            const config = getTimeframeConfig(timeframe);

            const tooltip = document.createElement('div');
            tooltip.className = 'fixed bg-slate-800 border border-slate-600 rounded-lg p-4 shadow-lg z-50 max-w-sm';
            tooltip.style.left = this.offsetLeft + 'px';
            tooltip.style.top = (this.offsetTop + this.offsetHeight + 5) + 'px';

            tooltip.innerHTML = `
                <div class="text-sm">
                    <div class="font-semibold text-slate-200 mb-2">Timeframe: ${timeframe}</div>
                    <div class="text-slate-400 mb-2">${config.description}</div>
                    <div class="text-xs text-slate-500">
                        <div>Update Rate: ${config.updateRate/1000}s</div>
                        <div>Max Points: ${config.maxPoints}</div>
                        <div>Aggregation: ${config.aggregation}</div>
                    </div>
                </div>
                <button class="mt-2 text-xs text-blue-400 hover:text-blue-300" onclick="this.parentElement.remove()">
                    Close
                </button>
            `;

            document.body.appendChild(tooltip);

            // Auto remove after 5 seconds
            setTimeout(() => {
                if (tooltip.parentNode) {
                    tooltip.remove();
                }
            }, 5000);
        });

        // Export functionality
        async function exportData() {
            if (!currentSymbol) {
                alert('Please select a symbol first');
                return;
            }

            const exportData = {
                symbol: currentSymbol,
                timestamp: new Date().toISOString(),
                performance: performanceMetrics,
                orderbook: null,
                trades: [],
                candles: []
            };

            try {
                // Fetch fresh data for export
                const [orderbookRes, tradesRes, candlesRes] = await Promise.allSettled([
                    fetch(`/api/symbol/${currentSymbol}/orderbook`),
                    fetch(`/api/symbol/${currentSymbol}/trades?limit=100`),
                    fetch(`/api/symbol/${currentSymbol}/micro-candles?timeframe=${document.getElementById('timeframe-selector').value}`)
                ]);

                if (orderbookRes.status === 'fulfilled' && orderbookRes.value.ok) {
                    exportData.orderbook = await orderbookRes.value.json();
                }

                if (tradesRes.status === 'fulfilled' && tradesRes.value.ok) {
                    const tradesData = await tradesRes.value.json();
                    exportData.trades = tradesData.trades || [];
                }

                if (candlesRes.status === 'fulfilled' && candlesRes.value.ok) {
                    const candlesData = await candlesRes.value.json();
                    exportData.candles = candlesData.candles || [];
                }

                // Create and download JSON file
                const dataStr = JSON.stringify(exportData, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                const url = URL.createObjectURL(dataBlob);

                const link = document.createElement('a');
                link.href = url;
                link.download = `microstructure_${currentSymbol}_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);

                // Show success message
                const exportBtn = document.getElementById('export-data');
                const originalText = exportBtn.textContent;
                exportBtn.textContent = '‚úÖ Exported';
                exportBtn.style.backgroundColor = '#10b981';
                setTimeout(() => {
                    exportBtn.textContent = originalText;
                    exportBtn.style.backgroundColor = '#059669';
                }, 2000);

            } catch (error) {
                console.error('Export failed:', error);
                alert('Export failed. Please try again.');
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Ctrl/Cmd + E for export
            if ((e.ctrlKey || e.metaKey) && e.key === 'e') {
                e.preventDefault();
                exportData();
            }

            // Ctrl/Cmd + R for refresh
            if ((e.ctrlKey || e.metaKey) && e.key === 'r') {
                e.preventDefault();
                document.getElementById('refresh-data').click();
            }

            // ESC to clear symbol selection
            if (e.key === 'Escape') {
                document.getElementById('symbol-selector').value = '';
                clearSymbolData();
            }
        });

        // Alert system functions
        function showAlert(type, message, data = {}) {
            const now = Date.now();
            const lastAlert = lastAlertTimes[type] || 0;

            if (now - lastAlert < ALERT_COOLDOWN) return;
            lastAlertTimes[type] = now;

            // Visual notification
            const alertDiv = document.createElement('div');
            alertDiv.className = 'fixed top-4 right-4 bg-red-600 text-white p-4 rounded-lg shadow-lg z-50 max-w-sm';
            alertDiv.innerHTML = `
                <div class="flex items-center justify-between">
                    <div>
                        <div class="font-semibold">${type.toUpperCase()} ALERT</div>
                        <div class="text-sm">${message}</div>
                        <div class="text-xs opacity-75">${new Date().toLocaleTimeString()}</div>
                    </div>
                    <button class="ml-4 text-white hover:text-gray-200" onclick="this.parentElement.parentElement.remove()">‚úï</button>
                </div>
            `;

            document.body.appendChild(alertDiv);

            // Auto remove after 10 seconds
            setTimeout(() => {
                if (alertDiv.parentNode) {
                    alertDiv.remove();
                }
            }, 10000);

            // Sound alert
            if (alertSettings.soundEnabled) {
                playAlertSound();
            }

            // Log to console
            console.warn(`üö® ${type} Alert:`, message, data);
        }

        function playAlertSound() {
            try {
                // Create audio context for beep sound
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.value = 800;
                oscillator.type = 'sine';

                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5);
            } catch (error) {
                console.warn('Could not play alert sound:', error);
            }
        }

        function checkAlerts(symbol, data) {
            if (!symbol || !data) return;

            // Spread alert
            if (data.spreadPercent && data.spreadPercent > alertSettings.spreadThreshold) {
                showAlert('spread', `${symbol}: Spread ${data.spreadPercent.toFixed(3)}% exceeds ${alertSettings.spreadThreshold}%`, data);
            }

            // Volume alert (simplified - would need historical data for proper implementation)
            if (data.volume && data.volume > 50000) { // Placeholder logic
                showAlert('volume', `${symbol}: High volume detected: ${data.volume.toLocaleString()}`, data);
            }

            // Price movement alert (would need price history)
            if (data.priceChange && Math.abs(data.priceChange) > alertSettings.priceThreshold) {
                showAlert('price', `${symbol}: Price moved ${data.priceChange.toFixed(2)}%`, data);
            }
        }

        // Alert panel management
        function loadAlertSettings() {
            try {
                const saved = localStorage.getItem('microstructure_alerts');
                if (saved) {
                    alertSettings = { ...alertSettings, ...JSON.parse(saved) };
                }
            } catch (error) {
                console.warn('Could not load alert settings:', error);
            }
        }

        function saveAlertSettings() {
            try {
                localStorage.setItem('microstructure_alerts', JSON.stringify(alertSettings));

                // Show success
                const saveBtn = document.getElementById('save-alerts');
                const originalText = saveBtn.textContent;
                saveBtn.textContent = '‚úÖ Saved';
                setTimeout(() => {
                    saveBtn.textContent = originalText;
                }, 1500);
            } catch (error) {
                console.error('Could not save alert settings:', error);
                alert('Failed to save settings');
            }
        }

        // Event listeners
        document.getElementById('export-data').addEventListener('click', exportData);

        // Alert system event listeners
        document.getElementById('alerts-config').addEventListener('click', () => {
            document.getElementById('alert-panel').classList.remove('hidden');

            // Populate current settings
            document.getElementById('spread-alert').value = alertSettings.spreadThreshold;
            document.getElementById('volume-alert').value = alertSettings.volumeThreshold;
            document.getElementById('price-alert').value = alertSettings.priceThreshold;
            document.getElementById('sound-alerts').checked = alertSettings.soundEnabled;
        });

        document.getElementById('close-alerts').addEventListener('click', () => {
            document.getElementById('alert-panel').classList.add('hidden');
        });

        document.getElementById('save-alerts').addEventListener('click', () => {
            alertSettings.spreadThreshold = parseFloat(document.getElementById('spread-alert').value) || 0.5;
            alertSettings.volumeThreshold = parseFloat(document.getElementById('volume-alert').value) || 200;
            alertSettings.priceThreshold = parseFloat(document.getElementById('price-alert').value) || 2.0;
            alertSettings.soundEnabled = document.getElementById('sound-alerts').checked;

            saveAlertSettings();
        });

        document.getElementById('test-alert').addEventListener('click', () => {
            showAlert('test', 'This is a test alert to verify the system is working correctly');
        });

        document.getElementById('refresh-data').addEventListener('click', function() {
            if (currentSymbol) {
                // Clear throttling to force immediate update
                lastUpdateTimes = {};
                loadSymbolStats(currentSymbol);
                loadOrderbook(currentSymbol);
                loadTradeFlow(currentSymbol);
                loadMicroCandles(currentSymbol);
            }
            loadSystemStats();
        });

        // HELP MODAL SYSTEM
        function showHelpModal(topic) {
            const helpContent = getHelpContent(topic);

            const modal = document.createElement('div');
            modal.id = 'help-modal';
            modal.className = 'fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 p-4';
            modal.onclick = (e) => { if (e.target === modal) closeHelpModal(); };

            modal.innerHTML = `
                <div class="bg-slate-900 border border-slate-700 rounded-xl max-w-3xl w-full max-h-[90vh] overflow-y-auto shadow-2xl">
                    <div class="sticky top-0 bg-slate-800 border-b border-slate-700 p-4 flex items-center justify-between">
                        <h2 class="text-xl font-bold text-slate-100">${helpContent.title}</h2>
                        <button onclick="closeHelpModal()" class="text-slate-400 hover:text-slate-200 transition-colors">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                            </svg>
                        </button>
                    </div>
                    <div class="p-6 space-y-6 text-slate-300">
                        ${helpContent.content}
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
        }

        function closeHelpModal() {
            const modal = document.getElementById('help-modal');
            if (modal) modal.remove();
        }

        function getHelpContent(topic) {
            const content = {
                orderbook: {
                    title: 'üìñ Live Orderbook - ≈†ta je i kako se koristi',
                    content: `
                        <div class="space-y-4">
                            <div>
                                <h3 class="text-lg font-semibold text-green-400 mb-2">≈†ta je Orderbook?</h3>
                                <p class="text-slate-400">Orderbook (knjiga naloga) prikazuje sve aktivne <span class="text-green-400">BUY</span> i <span class="text-red-400">SELL</span> naloge za odreƒëeni simbol. Gornji deo (crveno) su ASKS (prodavci), donji deo (zeleno) su BIDS (kupci).</p>
                            </div>

                            <div class="border-l-4 border-blue-500 pl-4">
                                <h4 class="font-semibold text-blue-400 mb-2">Spread - Kljuƒçna metrika</h4>
                                <p class="mb-2"><span class="font-mono bg-slate-800 px-2 py-1 rounded">Spread = Ask - Bid</span></p>
                                <ul class="list-disc list-inside space-y-1 text-sm">
                                    <li><span class="text-green-400">Manji spread (0.01 - 0.10)</span> = likvidniji market, idealno za scalping</li>
                                    <li><span class="text-yellow-400">Srednji spread (0.10 - 0.50)</span> = umeren, mo≈æe se raditi scalp ali oprezno</li>
                                    <li><span class="text-red-400">Veliki spread (>0.50)</span> = illikvidan market, IZBEGAVATI za scalp</li>
                                </ul>
                            </div>

                            <div>
                                <h4 class="font-semibold text-purple-400 mb-2">≈†ta pratiti za Scalping</h4>
                                <ul class="list-disc list-inside space-y-2 text-sm">
                                    <li><strong>Spread stabilnost:</strong> Ako se spread naglo ≈°iri, ƒåEKAJ - volatilnost raste</li>
                                    <li><strong>Size nivoi:</strong> Velike koliƒçine (>10 BTC za BTCUSDT) mogu biti "zidovi" - otpor/podr≈°ka</li>
                                    <li><strong>Best Bid/Ask:</strong> Ako se brzo menjaju - visoka aktivnost, dobro za scalp</li>
                                    <li><strong>Total USD vrednost:</strong> Nivoi sa >$500k su jaki support/resistance</li>
                                </ul>
                            </div>

                            <div class="bg-slate-800 p-4 rounded-lg">
                                <p class="text-sm text-slate-400"><strong>üí° Savjet:</strong> Za scalping tra≈æi simbole sa spread-om manjim od 0.05% cene (za BTC ~$85k = spread <$42). Stabilniji spread = predvidljiviji ulaz/izlaz.</p>
                            </div>
                        </div>
                    `
                },

                tradeFlow: {
                    title: 'üí± Trade Flow - Praƒáenje trejd aktivnosti',
                    content: `
                        <div class="space-y-4">
                            <div>
                                <h3 class="text-lg font-semibold text-green-400 mb-2">≈†ta je Trade Flow?</h3>
                                <p class="text-slate-400">Trade Flow prikazuje <strong>izvr≈°ene trades</strong> u real-time. Svaki red je stvarna transakcija izmeƒëu kupca i prodavca.</p>
                            </div>

                            <div>
                                <h4 class="font-semibold text-blue-400 mb-2">Simboli i njihovo znaƒçenje</h4>
                                <ul class="list-none space-y-2">
                                    <li><span class="text-green-400">‚Üó</span> <strong>BUY (Taker Buy):</strong> Agresivan kupac, kupio po ASK ceni - bullish signal</li>
                                    <li><span class="text-red-400">‚Üò</span> <strong>SELL (Taker Sell):</strong> Agresivan prodavac, prodao po BID ceni - bearish signal</li>
                                </ul>
                            </div>

                            <div class="border-l-4 border-purple-500 pl-4">
                                <h4 class="font-semibold text-purple-400 mb-2">Cifre - Price, Size, Time</h4>
                                <ul class="list-disc list-inside space-y-1 text-sm">
                                    <li><strong>Price:</strong> Cena po kojoj je trade izvr≈°en</li>
                                    <li><strong>Size:</strong> Koliƒçina koja je trejdovana (veƒáe = va≈ænije)</li>
                                    <li><strong>Time:</strong> Vreme izvr≈°enja</li>
                                </ul>
                            </div>

                            <div>
                                <h4 class="font-semibold text-yellow-400 mb-2">≈†ta pratiti za Scalping</h4>
                                <ul class="list-disc list-inside space-y-2 text-sm">
                                    <li><strong>Sekvence:</strong> Ako ima≈° 5-10 uzastopnih BUY ‚Üó - jak bullish momentum, razmisli o LONG poziciji</li>
                                    <li><strong>Velike koliƒçine:</strong> Trade sa >5 BTC (za BTCUSDT) = institucionalci, prati pravac</li>
                                    <li><strong>Brzina:</strong> Ako su trades ƒçe≈°ƒái (svake sekunde) = visoka volatilnost, dobro za scalp</li>
                                    <li><strong>Price clustering:</strong> Ako se trades izvr≈°avaju na istom price nivou = strong support/resistance</li>
                                </ul>
                            </div>

                            <div class="bg-slate-800 p-4 rounded-lg">
                                <p class="text-sm text-slate-400"><strong>‚ö° Scalp strategija:</strong> Ako vidi≈° naglu promenu smera (5x BUY ‚Üí 5x SELL) = moguƒá reversal, pripremi kontra poziciju ili zatvori postojeƒáu.</p>
                            </div>
                        </div>
                    `
                },

                liveMetrics: {
                    title: 'üìä Live Metrics - Kljuƒçni Market Indikatori',
                    content: `
                        <div class="space-y-4">
                            <div>
                                <h3 class="text-lg font-semibold text-green-400 mb-2">Obja≈°njenje svake metrike</h3>
                            </div>

                            <div class="border-l-4 border-blue-500 pl-4">
                                <h4 class="font-semibold text-blue-400 mb-1">Spread (apsolutna vrednost)</h4>
                                <p class="text-sm text-slate-400 mb-2"><code>Spread = Ask - Bid</code></p>
                                <ul class="list-disc list-inside space-y-1 text-sm">
                                    <li><span class="text-green-400">0.01-0.10:</span> Odliƒçan za scalping</li>
                                    <li><span class="text-yellow-400">0.10-0.50:</span> Prihvatljiv</li>
                                    <li><span class="text-red-400">>0.50:</span> Previ≈°e riziƒçan</li>
                                </ul>
                            </div>

                            <div class="border-l-4 border-purple-500 pl-4">
                                <h4 class="font-semibold text-purple-400 mb-1">Spread % (procentualna vrednost)</h4>
                                <p class="text-sm text-slate-400 mb-2"><code>Spread % = (Spread / Mid Price) √ó 100</code></p>
                                <ul class="list-disc list-inside space-y-1 text-sm">
                                    <li><span class="text-green-400"><0.01%:</span> Ultra-likvidan (BTC, ETH)</li>
                                    <li><span class="text-yellow-400">0.01-0.05%:</span> Dobar likviditet</li>
                                    <li><span class="text-red-400">>0.1%:</span> Slab likviditet, oprezno</li>
                                </ul>
                            </div>

                            <div class="border-l-4 border-cyan-500 pl-4">
                                <h4 class="font-semibold text-cyan-400 mb-1">Mid Price (srednja cena)</h4>
                                <p class="text-sm text-slate-400 mb-2"><code>Mid Price = (Bid + Ask) / 2</code></p>
                                <p class="text-sm">Referentna cena za praƒáenje trenda. Ako raste br≈æe od prosjeka = bullish.</p>
                            </div>

                            <div class="border-l-4 border-green-500 pl-4">
                                <h4 class="font-semibold text-green-400 mb-1">Volume (1m) - Volumen u poslednjih 60s</h4>
                                <ul class="list-disc list-inside space-y-1 text-sm">
                                    <li><span class="text-green-400">Visok volumen (>10,000):</span> Aktivna trgovina, dobro za scalp</li>
                                    <li><span class="text-yellow-400">Nizak volumen (<1,000):</span> Slaba aktivnost, te≈æe izvr≈°iti naloge</li>
                                </ul>
                            </div>

                            <div class="border-l-4 border-yellow-500 pl-4">
                                <h4 class="font-semibold text-yellow-400 mb-1">Trades (1m) - Broj trades u poslednjih 60s</h4>
                                <ul class="list-disc list-inside space-y-1 text-sm">
                                    <li><span class="text-green-400">>500 trades:</span> Visoka frekvencija, idealno za scalp</li>
                                    <li><span class="text-yellow-400">100-500:</span> Umerena aktivnost</li>
                                    <li><span class="text-red-400"><100:</span> Spor market</li>
                                </ul>
                            </div>

                            <div class="border-l-4 border-orange-500 pl-4">
                                <h4 class="font-semibold text-orange-400 mb-1">VWAP - Volume Weighted Average Price</h4>
                                <p class="text-sm text-slate-400 mb-2">Prosjeƒçna cena ponderisana volumenom. Koristi se kao referentna linija.</p>
                                <ul class="list-disc list-inside space-y-1 text-sm">
                                    <li>Ako je <strong>Price > VWAP:</strong> Bullish momentum</li>
                                    <li>Ako je <strong>Price < VWAP:</strong> Bearish momentum</li>
                                    <li>VWAP ƒçesto djeluje kao <strong>magnet</strong> - cena se vraƒáa ka njemu</li>
                                </ul>
                            </div>

                            <div class="bg-slate-800 p-4 rounded-lg">
                                <p class="text-sm text-slate-400"><strong>üéØ Idealna kombinacija za scalp:</strong> Spread% <0.02%, Volume >8,000, Trades >300, Cena blizu VWAP-a (potencijal za brz pokret).</p>
                            </div>
                        </div>
                    `
                },

                volumeProfile: {
                    title: 'üìä Volume Profile - Analiza volumena po ceni',
                    content: `
                        <div class="space-y-4">
                            <div>
                                <h3 class="text-lg font-semibold text-green-400 mb-2">≈†ta je Volume Profile?</h3>
                                <p class="text-slate-400">Volume Profile prikazuje <strong>distribuciju volumena po razliƒçitim price nivoima</strong>. Horizontalni chart pokazuje koliko je volumena trejdovano na svakoj ceni.</p>
                            </div>

                            <div class="border-l-4 border-blue-500 pl-4">
                                <h4 class="font-semibold text-blue-400 mb-2">Kako ƒçitati dijagram</h4>
                                <ul class="list-disc list-inside space-y-1 text-sm">
                                    <li><strong>Du≈æe ≈°ipke (‚Üí):</strong> Vi≈°e volumena trejdovano na toj ceni = va≈æan nivo</li>
                                    <li><strong>Kraƒáe ≈°ipke (‚Üí):</strong> Manje volumena = manje znaƒçajan nivo</li>
                                    <li><strong>Najdu≈æa ≈°ipka:</strong> <span class="text-yellow-400">Point of Control (POC)</span> - najaktivniji price nivo</li>
                                </ul>
                            </div>

                            <div>
                                <h4 class="font-semibold text-purple-400 mb-2">≈†ta znaƒçe razliƒçiti nivoi</h4>
                                <ul class="list-disc list-inside space-y-2 text-sm">
                                    <li><strong>High Volume Node (HVN):</strong> Veliki volumen na nivou = <span class="text-cyan-400">jak support/resistance</span></li>
                                    <li><strong>Low Volume Node (LVN):</strong> Mali volumen = cena ƒáe verovatno <span class="text-orange-400">brzo proƒái kroz taj nivo</span></li>
                                    <li><strong>Value Area:</strong> Zona gde se trejdovalo 70% volumena - "fair value" za taj simbol</li>
                                </ul>
                            </div>

                            <div class="border-l-4 border-yellow-500 pl-4">
                                <h4 class="font-semibold text-yellow-400 mb-2">Scalping strategije sa Volume Profile</h4>
                                <ul class="list-disc list-inside space-y-2 text-sm">
                                    <li><strong>Ulaz na LVN:</strong> Ako cena uƒëe u Low Volume zonu, oƒçekuj brz pokret - postavi TP/SL u≈æe</li>
                                    <li><strong>Bounce od HVN:</strong> Ako se cena pribli≈æi High Volume nivou, pripremi se za odbijanje (support/resistance)</li>
                                    <li><strong>POC kao magnet:</strong> Cena ƒçesto gravitira ka POC-u - ako je daleko, mo≈æda je ≈°ansa za mean reversion scalp</li>
                                    <li><strong>Break iznad HVN:</strong> Ako cena probije High Volume nivo sa volumenom - jak signal za momentum scalp</li>
                                </ul>
                            </div>

                            <div class="bg-slate-800 p-4 rounded-lg">
                                <p class="text-sm text-slate-400"><strong>üí° Pro tip:</strong> Kombineuj Volume Profile sa Orderbook - ako HVN odgovara velikom Bid/Ask "zidu", to je ULTRA jak support/resistance za scalp entry/exit.</p>
                            </div>
                        </div>
                    `
                },

                microCandles: {
                    title: 'üïØÔ∏è Micro Candles - Visokofrekventna analiza cene',
                    content: `
                        <div class="space-y-4">
                            <div>
                                <h3 class="text-lg font-semibold text-green-400 mb-2">≈†ta su Micro Candles?</h3>
                                <p class="text-slate-400">Micro Candles su <strong>candlestick dijagram na vrlo kratkim timeframe-ovima</strong> (1s - 15m). Omoguƒáavaju praƒáenje price action-a u realnom vremenu za ultra-brze scalp pozicije.</p>
                            </div>

                            <div class="border-l-4 border-blue-500 pl-4">
                                <h4 class="font-semibold text-blue-400 mb-2">Timeframe opcije - ≈†ta znaƒçe</h4>
                                <div class="space-y-3 text-sm">
                                    <div>
                                        <p class="font-semibold text-cyan-400">1s (Ultra High-Freq)</p>
                                        <ul class="list-disc list-inside ml-4 text-slate-400">
                                            <li>Svaka sveƒáica = 1 sekunda trgovanja</li>
                                            <li><span class="text-green-400">Idealno za:</span> Ultra-brz–µ scalp pozicije (5-15s hold)</li>
                                            <li><span class="text-red-400">Rizik:</span> Ekstremna volatilnost, –º–Ω–æ–≥–æ noise-a</li>
                                            <li><span class="text-yellow-400">Preporuka:</span> Samo za veoma likvidne parove (BTC, ETH)</li>
                                        </ul>
                                    </div>

                                    <div>
                                        <p class="font-semibold text-cyan-400">5s (High-Freq) - DEFAULT</p>
                                        <ul class="list-disc list-inside ml-4 text-slate-400">
                                            <li>Svaka sveƒáica = 5 sekundi</li>
                                            <li><span class="text-green-400">Idealno za:</span> Brze scalp pozicije (30s - 2min hold)</li>
                                            <li><span class="text-green-400">Najƒçe≈°ƒáe kori≈°ƒáen:</span> Dobar balans izmeƒëu brzine i ƒçitljivosti</li>
                                            <li><span class="text-yellow-400">Preporuka:</span> Najbolji izbor za veƒáinu scalp strategija</li>
                                        </ul>
                                    </div>

                                    <div>
                                        <p class="font-semibold text-cyan-400">15s (Med-Freq)</p>
                                        <ul class="list-disc list-inside ml-4 text-slate-400">
                                            <li>Svaka sveƒáica = 15 sekundi</li>
                                            <li><span class="text-green-400">Idealno za:</span> Srednji scalp (2-5min hold)</li>
                                            <li>Manje noise-a, jasniji trendovi</li>
                                        </ul>
                                    </div>

                                    <div>
                                        <p class="font-semibold text-cyan-400">30s - 1m (Low-Freq)</p>
                                        <ul class="list-disc list-inside ml-4 text-slate-400">
                                            <li>Svaka sveƒáica = 30s ili 1 minuta</li>
                                            <li><span class="text-green-400">Idealno za:</span> Sporiji scalp (5-15min hold)</li>
                                            <li>Najbolje za identifikaciju clear pattern-a</li>
                                        </ul>
                                    </div>

                                    <div>
                                        <p class="font-semibold text-cyan-400">5m - 15m (Smooth/Trend)</p>
                                        <ul class="list-disc list-inside ml-4 text-slate-400">
                                            <li>Svaka sveƒáica = 5 ili 15 minuta</li>
                                            <li><span class="text-green-400">Idealno za:</span> Trend identifikaciju, ne za ultra-scalp</li>
                                            <li>Koristi za big picture pre ulaska u scalp</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>

                            <div class="border-l-4 border-purple-500 pl-4">
                                <h4 class="font-semibold text-purple-400 mb-2">Razumevanje osa dijagrama</h4>
                                <div class="space-y-2 text-sm">
                                    <div>
                                        <p class="font-semibold text-yellow-400">X-osa (donja - horizontalna)</p>
                                        <ul class="list-disc list-inside ml-4 text-slate-400">
                                            <li><strong>Znaƒçenje:</strong> Timestamp (vreme) kada je svaka sveƒáica zapoƒçela</li>
                                            <li>Prikazuje se kao Unix timestamp ili formatovan datum/vreme</li>
                                            <li><strong>Primer:</strong> "1763895103" ili "10:51:43"</li>
                                            <li>Levo = starije vreme, Desno = novije vreme</li>
                                        </ul>
                                    </div>

                                    <div>
                                        <p class="font-semibold text-yellow-400">Y-osa (levo - vertikalna)</p>
                                        <ul class="list-disc list-inside ml-4 text-slate-400">
                                            <li><strong>Znaƒçenje:</strong> Cena (Price) u USD ili USDT</li>
                                            <li>Gor–µ = vi≈°a cena, Dole = ni≈æa cena</li>
                                            <li><strong>Primer:</strong> Za BTC mo≈æe biti 85,800 - 86,000</li>
                                            <li>Auto-scale: automatski se prilagoƒëava min/max ceni u dijagramu</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>

                            <div class="border-l-4 border-green-500 pl-4">
                                <h4 class="font-semibold text-green-400 mb-2">Kako ƒçitati sveƒáice (Candles)</h4>
                                <div class="space-y-2 text-sm">
                                    <ul class="list-disc list-inside text-slate-400">
                                        <li><strong class="text-green-400">Zelena/Bijela sveƒáica:</strong> Close > Open (cena porasla u tom periodu) - BULLISH</li>
                                        <li><strong class="text-red-400">Crvena/Crna sveƒáica:</strong> Close < Open (cena pala u tom periodu) - BEARISH</li>
                                        <li><strong>Telo sveƒáice:</strong> Razlika izmeƒëu Open i Close cene</li>
                                        <li><strong>Gornji fitilj (wick):</strong> Najvi≈°a cena (High) dostignuta u tom periodu</li>
                                        <li><strong>Donji fitilj:</strong> Najni≈æa cena (Low) dostignuta u tom periodu</li>
                                        <li><strong>Du≈æe telo:</strong> Jaƒçi trend (vi≈°e kupaca/prodavaca)</li>
                                        <li><strong>Du≈æi fitilji:</strong> Vi≈°e rejections na tim nivoima (support/resistance)</li>
                                    </ul>
                                </div>
                            </div>

                            <div class="border-l-4 border-orange-500 pl-4">
                                <h4 class="font-semibold text-orange-400 mb-2">≈†ta je pogodno za Scalping</h4>
                                <div class="space-y-2 text-sm">
                                    <ul class="list-disc list-inside text-slate-400">
                                        <li><span class="text-green-400">‚úÖ Male sveƒáice sa malim body-em:</span> Niska volatilnost, predikativan market</li>
                                        <li><span class="text-green-400">‚úÖ Konzistentne zelene/crvene sekvence:</span> Clear trend, lako pratiti momentum</li>
                                        <li><span class="text-green-400">‚úÖ 5s-15s timeframe:</span> Dovoljan detalj bez previ≈°e noise-a</li>
                                        <li><span class="text-red-400">‚ùå Velike sveƒáice sa dugim fitiljima:</span> Visoka volatilnost, te≈°ko kontrolisati SL</li>
                                        <li><span class="text-red-400">‚ùå Haotiƒçan pattern (gore-dole-gore):</span> Nema jasnog trenda, ƒçekaj</li>
                                        <li><span class="text-yellow-400">‚ö†Ô∏è Doji sveƒáice (Open ‚âà Close):</span> Indecizija, moguƒá reversal ili konsolidacija</li>
                                    </ul>
                                </div>
                            </div>

                            <div class="border-l-4 border-cyan-500 pl-4">
                                <h4 class="font-semibold text-cyan-400 mb-2">Scalping strategije sa Micro Candles</h4>
                                <div class="space-y-2 text-sm">
                                    <ul class="list-disc list-inside text-slate-400">
                                        <li><strong>Trend Following:</strong> Ako vidi≈° 5-10 zelenih sveƒáica uzastopno na 5s = LONG, postavi SL ispod najni≈æe sveƒáice</li>
                                        <li><strong>Breakout Scalp:</strong> Ako cena probije prethodni High sa velikom zelenom sveƒáicom = momentum entry</li>
                                        <li><strong>Support/Resistance Bounce:</strong> Donji fitilj na istoj ceni 3x uzastopno = jak support, ulazi LONG</li>
                                        <li><strong>Mean Reversion:</strong> Nakon 10+ sveƒáica u jednom smeru, oƒçekuj reversal - pripremi se za kontra poziciju</li>
                                        <li><strong>Volume Confirmation:</strong> Veliki volumen + velika zelena sveƒáica = validan bullish signal</li>
                                    </ul>
                                </div>
                            </div>

                            <div class="bg-slate-800 p-4 rounded-lg">
                                <p class="text-sm text-slate-400"><strong>üéØ Pro setup:</strong> Koristi <strong>5s timeframe</strong>, posmatraj pattern od 50-100 sveƒáica (~4-8min historije). Tra≈æi clear trendove sa 5+ zelenih ili crvenih sveƒáica uzastopno. Entry na pullback, TP nakon 0.02-0.05% pomera, SL na 0.03% ispod entry.</p>
                            </div>
                        </div>
                    `
                }
            };

            return content[topic] || { title: 'Help', content: '<p>No content available</p>' };
        }

        // Close modal on ESC key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') closeHelpModal();
        });
    </script>

</body>
</html>
