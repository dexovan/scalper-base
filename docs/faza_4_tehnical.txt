## ğŸš€ **PHASE 04 â€” FEATURE ENGINE (ULTRA DETALJNA TEHNIÄŒKA SPECIFIKACIJA)**

### *Final Spec Â· Professional Edition Â· Fully Aligned With Phase 1â€“3 Infrastructure*

---

# ğŸ”¥ **UVOD â€” Å ta ova faza radi i ZAÅ TO je kljuÄna**

Do Phase 3 tvoj sistem je:

* imao taÄan list simbola (universe)
* imao stabilne WS konekcije
* imao microstructure podatke:

  * orderbook (depth)
  * trade stream
  * micro-candles (1s, 3s, 5s, 15s)
* imao JSON storage
* imao dashboard API za osnovne informacije

Ali joÅ¡ uvek **nije imao INTELIGENTNO RAZUMEVANJE TRÅ½IÅ TA**.

**PHASE 04** uvodi upravo to â†’ *prvi pravi AI sloj*:

* orderbook imbalance
* wall detection
* spoof detection
* flow/delta analiza
* volatility engine
* pump pre-signali
* fee/leverage znaÄenje (â€œkoliko cena mora da se pomeri da bi trade bio profitabilanâ€)

Sve ovo postaje **jedna centralna FeatureState matrica** za svaki simbol.

Ovaj FeatureState je srce sistema â€” sve kasnije faze (regime engine, scoring engine, state machine, execution) koriste GA.

---

# ğŸ§± **GLAVNA ARHITEKTURA FAZE 4**

ÄŒitava Feature Engine arhitektura deli se na 7 podsistema:

```
src/features/
    orderbookImbalance.js
    wallsSpoofing.js
    flowDelta.js
    volatilityEngine.js
    feeLeverageEngine.js
    pumpPreSignals.js
    featureEngine.js
```

Sve ovo se zasniva na microstructure iz Phase 3:

```
src/market/microstructure.js
```

Plus JSON metrics storage:

```
data/metrics/<symbol>.json
```

I novi API route:

```
GET /api/symbol/:symbol/features
```

---

# ğŸ“¦ **1) FEATURE STATE â€” MASTER STRUKTURA**

Za svaki simbol postoji kompletna FeatureState struktura:

```ts
FeatureState = {
    symbol: string,
    lastUpdateAt: ISOString,
    imbalance: { ... },
    walls: { ... },
    spoofing: { ... },
    flow: { ... },
    volatility: { ... },
    feeLeverage: { ... },
    pumpSignals: { ... }
}
```

Ona je:

* u memori (FeatureEngineState)
* i na disku (JSON snapshot)
* i dostupna preko API-ja (dashboard)

---

# ğŸ” **2) FEATURE MODULI â€” DETALJNE SPECIFIKACIJE**

Sada idemo modul po modul, najdetaljnije moguÄ‡e.

---

# ğŸ“˜ **2.1 ORDERBOOK IMBALANCE ENGINE**

### *File: src/features/orderbookImbalance.js*

### **Cilj**

IzraÄunati realno stanje balansa (i disbalansa) knjige naloga:

* ko kontroliÅ¡e TOB (top-of-book)
* ko kontroliÅ¡e SHORT/MID/FAR zone (depth zones)
* koliko je signal stabilan (confidence score)

### **Input**

Iz Phase 3:

```
orderbookSummary = microstructure.getOrderbookSummary(symbol, depth)
```

### **Output:**

```json
imbalance: {
    tobImbalance: number,
    zoneImbalanceShortTerm: number,
    zoneImbalanceMidTerm: number,
    zoneImbalanceFarTerm: number,
    imbalancedSide: "BUY" | "SELL" | "NONE",
    confidence: number
}
```

### **Najbolja profesionalna implementacija (algoritamski)**

#### **a) TOB imbalance formula**

```
tob = (bid_qty - ask_qty) / (bid_qty + ask_qty)
```

Range: -1 â†’ +1

#### **b) Zone definicije**

Najbolja empirijska reÅ¡enja za crypto scalping:

| Zona  | Range od mid price |
| ----- | ------------------ |
| short | 0.00% â€“ 0.05%      |
| mid   | 0.05% â€“ 0.15%      |
| far   | 0.15% â€“ 0.40%      |

#### **c) Imbalance formule**

```
zoneImbalance = (sumBids - sumAsks) / (sumBids + sumAsks)
```

#### **d) Dominant side**

Ako:

* tobImbalance > +0.25 â†’ BUY
* tobImbalance < -0.25 â†’ SELL
* inaÄe: NONE

#### **e) Confidence**

Bazirano na:

* kolika je konzistentnost izmeÄ‘u zona (koliko zona ima isti znak)
* koliki je ukupni depth (viÅ¡e depth â†’ veÄ‡a pouzdanost)
* brzina updejta

Score: 0 â†’ 1

---

# ğŸš§ **2.2 WALLS & SPOOFING ENGINE**

### *File: src/features/wallsSpoofing.js*

## **WALL DETECTION**

### Zid (wall) je definisan kao nivo gde:

```
qty > avg_qty * K
```

Najbolja vrednost K (testirano u profesionalnim sistemima):
â¡ï¸ **K = 8**

### Proizvodi:

```
hasBidWall
bidWallPrice
bidWallStrength
â€¦
hasAskWall
askWallStrength
absorption scores
```

---

## **SPOOF DETECTION (najvaÅ¾niji deo)**

Spoofing se detektuje kao:

1. Veliki zid se pojavi
2. Cena krene ka njemu
3. Zid nestane pre kontakta

â†’ to znaÄi manipulacija.

TakoÄ‘e:

* mnogo cancel eventova
* zid koji se teleportuje
* abnormalno tanki depth u normalnoj fazi

### Output:

```
spoofingScore: 0â€“1
recentSpoofEvents: number
spoofOnBidSide
spoofOnAskSide
```

---

# ğŸ”¥ **2.3 FLOW / DELTA ENGINE**

### *File: src/features/flowDelta.js*

Ovo je â€œtraders attacking pressure engineâ€.

### **Input:** tradeTick buffer iz Phase 3

### **Window-i za flow:**

* 1s
* 5s
* 15s

### Formula:

```
delta = buyVolume - sellVolume
ratio = delta / (buyVolume + sellVolume)
```

### Output:

```
buyVolume1s, sellVolume1s, deltaVolume1s
...
deltaRatio1s, deltaRatio5s, deltaRatio15s
currentDominantSide
dominanceStreakSeconds
```

### Dominant side:

Ako deltaRatio > 0.2 â†’ BUY
Ako deltaRatio < -0.2 â†’ SELL
InaÄe: NONE

### Dominance streak:

Broj sekundi koliko delta nije promenila znak.

---

# âš¡ **2.4 VOLATILITY ENGINE**

### *File: src/features/volatilityEngine.js*

### â–º Najbolji volatility engine za micro scalping je **micro ATR**

Koristimo micro-candles iz Phase 3:

```
1s ATR  = avg(high-low, last 14)
5s ATR  = avg(high-low, last 14)
15s ATR = avg(high-low, last 14)
```

### Output:

```
atr1s, atr5s, atr15s
volatilityScore
explosionFlag
explosionStrength
```

### volatilityScore mapping:

ATR se normaliÅ¡e protiv rolling window max:

```
volatilityScore = ATR_now / ATR_max_last_300s
```

### explosionFlag:

Ako:

```
ATR_now > ATR_avg_last_300s * 3
```

---

# ğŸ’¸ **2.5 FEE & LEVERAGE ENGINE**

### *File: src/features/feeLeverageEngine.js*

### Input:

* CONFIG fees
* symbolMeta.maxLeverage
* volatility engine
* symbolProfile (Phase 2)

### Output:

```
assumedMakerFeeRate
assumedTakerFeeRate
minMoveForProfitMaker
minMoveForProfitTaker
defaultLeverage
liqSafetyScore
```

### minMoveForProfit idealna formula:

```
minMoveMaker = (makerFee*2) + slippage + volatilityImpact
```

Slippage se procenjuje iz ATR:

```
slippage â‰ˆ atr1s / price
```

### Liquidation safety score:

```
liqSafety = 1 - (volatilityScore * (defaultLeverage / maxLeverage))
```

---

# ğŸ“ˆ **2.6 PUMP PRE-SIGNALS ENGINE**

### *File: src/features/pumpPreSignals.js*

Pump detection je jedna od najteÅ¾ih komponenti.

### koristi:

* price change %
* volume spikes
* trades-per-second
* orderbook ThinScore

### Output:

```
priceChange5sPct
priceChange15sPct
priceChange60sPct
volumeSpike5s
volumeSpike15s
tradesPerSecond5s
tradesPerSecond15s
orderbookThinScore
pumpLikelihoodScore
```

### Najbolja heuristika:

```
pumpLikelihood =
    w1*priceChange5s +
    w2*volumeSpike5s +
    w3*orderbookThinScore +
    w4*tradesPerSecond5s
```

Najbolji profesionalni weight-ovi:

```
w1 = 0.40
w2 = 0.30
w3 = 0.20
w4 = 0.10
```

---

# ğŸ§  **3) CENTRALNI FEATURE ENGINE**

### *File: src/features/featureEngine.js*

Ovo je orchestrator.

### Funkcije:

### **initFeatureEngine()**

* uÄitava Universe
* inicijalizuje FeatureState
* pravi update loop (svakih 1000ms)

### **updateFeaturesForSymbol(symbol)**

Radi sledeÄ‡e:

1. povlaÄi orderbook & trades & candles
2. raÄuna:

   * imbalance
   * walls
   * spoofing
   * flow
   * volatility
   * fee/leverage
   * pump pre-signale
3. sklapa FeatureState
4. Äuva u:

   * memoriji
   * data/metrics/<symbol>.json

### **updateAllFeatures()**

ObraÄ‘uje sve simbole â€” ali sa throttling-om:

* Prime: svaki sekund
* Normal: svakih 2â€“3 sekunde
* Wild: svakih 5 sekundi

*(najbolji balans CPU-a i kvaliteta)*

---

# ğŸŒ **4) API ENDPOINTS**

## **GET /api/symbol/:symbol/features**

Response:

```
{
  symbol,
  lastUpdateAt,
  imbalance,
  walls,
  spoofing,
  flow,
  volatility,
  feeLeverage,
  pumpSignals
}
```

## **GET /api/features/overview**

Za prikaz hotlist:

```
symbol
tobImbalance
spoofingScore
volatilityScore
pumpLikelihoodScore
```

---

# ğŸ©º **5) HEALTH MODULE DODACI**

services.featureEngine:

```
status: OK | INIT | DEGRADED | DOWN
lastUpdateAt
symbolsUpdatedLastCycle
updateIntervalMs
```

---

# ğŸ§ª **6) TEST PLAN (12 profesionalnih testova)**

### Test 1 â€” Orderbook imbalance

Simulirati ekstremno jaka bid strana â†’ imbalance > 0.5

### Test 2 â€” Walls

Napraviti laÅ¾ni wall â†’ mora biti detektovan

### Test 3 â€” Spoofing

Zid koji nestaje pre udarca â†’ spoofingScore mora rasti

### Test 4 â€” Flow dominance

5 sekundi BUY-only trades â†’ dominantSide=BUY

### Test 5 â€” Volatility explosion

Naglo poveÄ‡anje high-low â†’ explosionFlag=true

### Test 6 â€” Fee/minMove correctness

RuÄno izraÄunati maker scenario â†’ mora biti identiÄan

### Test 7 â€” Pump pre-signal

Napraviti price spike + volume spike â†’ pumpLikelihood > 0.80

### Test 8 â€” JSON snapshot

data/metrics/BTCUSDT.json mora postojati

### Test 9 â€” API endpoint

/api/symbol/BTCUSDT/features mora vratiti kompletan FeatureState

### Test 10 â€” CPU throttling

FeatureEngine ne sme frcati CPU preko 40%

### Test 11 â€” Multi-symbol stress

50 simbola istovremeno â†’ sistem stabilan

### Test 12 â€” Restart recovery

posle restarta engine mora regenerisati FeatureState iz fresh microstructure

---

# ğŸ§© **7) FINALNI REZULTAT FAZE 4**

Kada se ova faza zavrÅ¡i, tvoj sistem dobija:

## âœ”ï¸ PRAVI INTELIGENTNI SLOJ

Sistem razume:

* ko dominira orderbook
* da li postoji manipulacija
* da li je trÅ¾iÅ¡te u eksploziji
* koliko je trÅ¾iÅ¡te opasno zbog fee + volatility
* da li poÄinje pump pre-signal

## âœ”ï¸ PODACI SU DOSTUPNI:

* u memoriji
* na disku
* preko API-ja
* u dashboard-u

## âœ”ï¸ PRIPREMA ZA FAZU 5

(Scoring Engine + Regime Engine)
â€” gde tvoj bot dobija mozak.

---

# ğŸŸ© **FAZA 4 â€” SPREMNA**

Ako Å¾eliÅ¡, mogu odmah da nastavim sa:

### **A) FAZA 5 â€” REGIME ENGINE (ultra detaljna spec)**

ili

### **B) FAZA 5 + kompletan kod**

ili

### **C) Implementaciju FAZE 4 (sav kod)**

Samo reci Å¡ta hoÄ‡eÅ¡ dalje.
