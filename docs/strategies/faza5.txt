Idemo FAZA 5 üî•
(*TP1/TP2/TP3, DCA, breakeven, recovery ‚Äì sve po Andre pravilima, bez SL pre TP1, bez trailing-a.*)

---

# **FAZA 5 ‚Äì POSITION MANAGEMENT**

**(TP1 / TP2 / TP3, DCA, Breakeven, Recovery)**
Verzija: 1.0 ‚Äì ƒçisto tehniƒçka specifikacija za implementaciju

---

## üéØ 5.0. CILJ FAZE

Kad FAZA 3 ka≈æe: **‚ÄúENTER SHORT/LONG @ price X, size Y, score Z‚Äù**
FAZA 5 preuzima sve dalje:

1. Otvara poziciju na berzi
2. Postavlja TP1 / TP2 / TP3
3. Postavlja DCA levele
4. Prati cenu u realnom vremenu
5. Izvr≈°ava TP-ove i DCA kada se pogode
6. Nakon TP1 pomera SL na breakeven (entry)
7. Zatvara poziciju i pravi ƒçist trade record

Sve po Andre pravilima:

* ‚ùå NEMA inicijalnog SL-a (pre TP1)
* ‚ùå NEMA trailing SL-a
* ‚úÖ DCA kao osiguranje
* ‚úÖ TP1/TP2/TP3 samo
* ‚úÖ Breakeven tek POSLE TP1

---

## üìÅ 5.1. Struktura fajlova / modula

```text
src/
  position/
    positionManager.js       # glavni API, orkestracija
    positionStore.js         # storage (in-memory + file/db)
    tpEngine.js              # logika TP1/TP2/TP3
    dcaEngine.js             # logika DCA nivoa
    slEngine.js              # breakeven posle TP1
    priceWatcher.js          # stream cena za aktivne pozicije
    pnlCalculator.js         # proraƒçun PnL-a, ROI, avg entry
    events.js                # event emitter (position_entered, tp_hit, dca_hit...)
```

> FAZA 7 ƒáe koristiti ove module za stvarno slanje naloga na Bybit.
> FAZA 5 je 90% exchange-agnostic ‚Äì radi sa apstraktnim ‚Äúorders‚Äù.

---

## üìê 5.2. Osnovne konstante & konfiguracija (Andre parametri)

```ts
// config/tradingConfig.js

export const POSITION_CONFIG = {
  leverage: 25,
  basePositionSize: 25,      // USDT po trejdu u startu
  maxDcaLevels: 3,

  tp: {
    // izra≈æeno u ROI % na marginu
    tp1Roi: 21,              // +21% ROI ‚Üí ‚âà +0.84% price move @ 25x
    tp2Roi: 41,              // +41% ROI ‚Üí ‚âà +1.64%
    tp3Roi: 100,             // +100% ROI ‚Üí ‚âà +4%
    exitFractions: [0.4, 0.3, 0.3] // 40% / 30% / 30%
  },

  dca: {
    // izra≈æeno u % PRICE AGAINST direction
    levels: [5, 15, 35],     // Entry +5%, +15%, +35% protiv pozicije
    mode: 'standard'         // 'standard' ili 'high_risk' opcija kasnije
  },

  risk: {
    useInitialStopLoss: false,
    moveToBreakevenAfterTp1: true,
    cancelDcaAfterTp1: true
  }
};
```

---

## üß± 5.3. Data strukture

### 5.3.1. `Position`

```ts
type Side = 'LONG' | 'SHORT';

type PositionState =
  | 'PENDING_OPEN'
  | 'OPEN'
  | 'RISK_FREE'
  | 'CLOSING'
  | 'CLOSED'
  | 'CANCELLED'
  | 'ERROR';

type Position = {
  id: string;                   // internal UUID
  symbol: string;               // "RADUSDT"
  side: Side;
  leverage: number;

  // sizing
  baseMargin: number;           // npr 25 USDT
  addedMargin: number;          // posle DCA-ova
  totalMargin: number;          // base + added

  // entry
  avgEntryPrice: number;        // dinamiƒçki (posle DCA se menja)
  entryTime: number;            // timestamp
  entryOrders: OrderRef[];      // referenca na stvarne naloge

  // tp
  tpLevels: TpLevel[];          // TP1/2/3
  dcaLevels: DcaLevel[];        // za ovu poziciju

  // runtime
  filledSize: number;           // total qty
  closedSize: number;           // do sada zatvoreno
  realizedPnl: number;          // u USDT
  state: PositionState;

  // flags
  tp1Hit: boolean;
  tp2Hit: boolean;
  tp3Hit: boolean;
  slAtBreakevenActive: boolean; // SL pomeren
  dcaActiveLevels: number;      // koliko DCA ispaljeno

  // meta
  score: number;                // FAZA 3 scoring
  context: any;                 // bilo koji dodatni context
};
```

### 5.3.2. `TpLevel`

```ts
type TpLevel = {
  index: 1 | 2 | 3;
  roiTarget: number;            // 21, 41, 100
  priceTarget: number;          // calculated from avgEntryPrice
  fraction: number;             // 0.4, 0.3, 0.3
  orderId?: string;             // exchange ID
  filled: boolean;
  filledSize: number;
  filledValue: number;          // u USDT
  hitTime?: number;
};
```

### 5.3.3. `DcaLevel`

```ts
type DcaLevel = {
  index: 1 | 2 | 3;
  adverseMovePct: number;       // 5, 15, 35
  triggerPrice: number;         // cena na kojoj pucamo DCA
  orderId?: string;
  executed: boolean;
  executedSize: number;
  executedPrice?: number;
  execTime?: number;
};
```

---

## üßÆ 5.4. Formula za TP / DCA cene

### 5.4.1. TP price iz ROI targeta

Target ROI (na marginu) ‚Üí koliko % treba da se pomeri cena.

```ts
priceMovePct = roiTarget / leverage
```

Za LONG:

```ts
tpPrice = entryPrice * (1 + priceMovePct / 100)
```

Za SHORT:

```ts
tpPrice = entryPrice * (1 - priceMovePct / 100)
```

Primer: ROI 21%, 25x, SHORT @ 0.4550

* priceMovePct = 21 / 25 = 0.84%
* tpPrice = 0.4550 * (1 - 0.0084) ‚âà 0.4512

### 5.4.2. DCA price iz adverse move %

Adverse move = koliko je cena oti≈°la PROTIV nas.

Za SHORT (cene idu gore):

```ts
dcaPrice = entryPrice * (1 + adverseMovePct / 100)
```

Za LONG (cene idu dole):

```ts
dcaPrice = entryPrice * (1 - adverseMovePct / 100)
```

---

## üîÑ 5.5. FLOW FAZE 5 ‚Äì ≈æivot jednog trade-a

### 5.5.1. Ulaz (iz FAZA 3 / decision engine)

```ts
type EntryDecision = {
  symbol: string;
  side: Side;
  confidenceScore: number;      // 70-100
  entryPrice: number;           // trenutni market
  margin: number;               // baseMargin (npr 25 USDT)
  leverage: number;             // 25x
  context: any;                 // log info
};
```

`positionManager.openPosition(decision)`:

1. Validira da nema blokade iz FAZA 4 (jo≈° jednom ako hoƒáe≈°).

2. Kreira `Position` objekat u stanju `PENDING_OPEN`.

3. Izraƒçuna poƒçetni `qty` (koliƒçinu):

   ```ts
   notional = margin * leverage;
   qty = notional / entryPrice;
   ```

4. Napravi MARKET order (preko FAZA 7 adaptera).

5. Kad order fillovan ‚Üí postavi:

   * `avgEntryPrice`
   * `filledSize`
   * `state = 'OPEN'`
   * generi≈°e TP i DCA nivoe
   * startuje `priceWatcher` za tu poziciju

---

## üéØ 5.6. TP Engine (tpEngine.js)

### 5.6.1. Setup TP nivoa

```js
export function setupTpLevels(position) {
  const { tp1Roi, tp2Roi, tp3Roi, exitFractions } = POSITION_CONFIG.tp;
  const entry = position.avgEntryPrice;
  const side = position.side;

  const roiTargets = [tp1Roi, tp2Roi, tp3Roi];

  position.tpLevels = roiTargets.map((roi, idx) => {
    const movePct = roi / position.leverage;
    let priceTarget;

    if (side === 'LONG') {
      priceTarget = entry * (1 + movePct / 100);
    } else {
      priceTarget = entry * (1 - movePct / 100);
    }

    return {
      index: (idx + 1),
      roiTarget: roi,
      priceTarget,
      fraction: exitFractions[idx],
      filled: false,
      filledSize: 0,
      filledValue: 0
    };
  });
}
```

> U FAZI 7, za svaki TP ƒáe se napraviti Limit order na toj ceni
> (ili ƒáemo u FAZI 5 raditi ‚Äúvirtual TPs‚Äù i market naloge na delu pozicije).

### 5.6.2. Monitoring TP hitova

`priceWatcher` ≈°alje event svaki put kada se promeni last price.

```js
function onPriceUpdate(position, lastPrice) {
  checkTpHits(position, lastPrice);
  checkDcaHits(position, lastPrice);
}
```

`checkTpHits`:

* Za svaku TP koja nije `filled`:

  * SHORT:

    * Ako `lastPrice <= tp.priceTarget` ‚Üí TP hit
  * LONG:

    * Ako `lastPrice >= tp.priceTarget` ‚Üí TP hit

* Kad se TP hit:

  1. Izraƒçunaj quantity za zatvaranje:

     ```ts
     qtyToClose = position.filledSize * tp.fraction
     ```

  2. Po≈°alji MARKET close order (FAZA 7).

  3. A≈æuriraj:

     ```ts
     position.closedSize += qtyToClose
     position.realizedPnl += calcPnl(...)
     tp.filled = true
     tp.filledSize = qtyToClose
     tp.hitTime = now()
     ```

  4. Emituj event: `tp_hit` (index 1/2/3).

### 5.6.3. Breakeven trigger (posle TP1)

* Kad `tp1` prvi put postane `filled`:

  * `slAtBreakevenActive = true`
  * FAZA 7: postavi SL order na `avgEntryPrice`
  * FAZA 5: otka≈æi sve DCA levele (`cancelDcaForPosition`)

> Od tog trenutka trade je ‚ÄúRISK FREE‚Äù ‚Üí samo mo≈æe da izaƒëe na 0 ili u plus.

---

## üßØ 5.7. DCA Engine (dcaEngine.js)

### 5.7.1. Inicijalno generisanje DCA nivoa

```js
export function setupDcaLevels(position) {
  const { levels } = POSITION_CONFIG.dca;
  const entry = position.avgEntryPrice;
  const side = position.side;

  position.dcaLevels = levels.map((pct, idx) => {
    let triggerPrice;
    if (side === 'LONG') {
      // cena pada protiv nas
      triggerPrice = entry * (1 - pct / 100);
    } else {
      // SHORT ‚Äì cena raste protiv nas
      triggerPrice = entry * (1 + pct / 100);
    }

    return {
      index: (idx + 1),
      adverseMovePct: pct,
      triggerPrice,
      executed: false,
      executedSize: 0
    };
  });
}
```

### 5.7.2. Monitoring DCA okidaƒça

`checkDcaHits(position, lastPrice)`:

Za svaki DCA level koji nije executed:

* Za LONG:

  * Ako `lastPrice <= triggerPrice` ‚Üí aktiviraj DCA

* Za SHORT:

  * Ako `lastPrice >= triggerPrice` ‚Üí aktiviraj DCA

### 5.7.3. Kada se DCA okine:

1. Proveri da li `slAtBreakevenActive`:

   * ako **DA** ‚Üí **NE RADIMO VI≈†E DCA** (posle TP1 nema DCA)

2. Izraƒçunaj dodatnu marginu: u osnovi ista kao start (`baseMargin`), npr. 25 USDT

3. Izraƒçunaj qty:

   ```ts
   extraNotional = dcaMargin * leverage;
   extraQty = extraNotional / lastPrice;
   ```

4. Po≈°alji MARKET order u smeru pozicije (dodaj size).

5. A≈æuriraj:

   ```ts
   position.addedMargin += dcaMargin;
   position.totalMargin = position.baseMargin + position.addedMargin;
   position.filledSize += extraQty;
   position.avgEntryPrice = recalcAvgEntry(position, extraQty, lastPrice);
   dca.executed = true;
   dca.executedSize = extraQty;
   dca.executedPrice = lastPrice;
   dca.execTime = now();
   position.dcaActiveLevels++;
   ```

6. **Rekalkuli≈°i TP levele** iz nove `avgEntryPrice`:

   * Override svih `tpLevels.priceTarget` (dok ne pogodi TP1, posle TP1 vi≈°e ne dira≈°).

---

## üßÆ 5.8. PnL & avgEntry kalkulacije (pnlCalculator.js)

### 5.8.1. Novi avgEntry posle DCA

```js
export function recalcAvgEntry(position, extraQty, extraPrice) {
  const oldNotional = position.avgEntryPrice * position.filledSize;
  const newNotional = extraPrice * extraQty;
  const totalQty = position.filledSize + extraQty;

  return (oldNotional + newNotional) / totalQty;
}
```

### 5.8.2. PnL za zatvaranje dela pozicije

Za LONG:

```ts
pnl = (closePrice - avgEntryPrice) * qty
```

Za SHORT:

```ts
pnl = (avgEntryPrice - closePrice) * qty
```

ROI na marginu:

```ts
roiPct = (pnl / position.totalMargin) * 100
```

---

## üß† 5.9. State Machine unutar FAZE 5

Pozicija menja state:

1. `PENDING_OPEN` ‚Üí poslat entry order
2. `OPEN` ‚Üí entry fillovan, TP i DCA aktivni
3. `RISK_FREE` ‚Üí TP1 hit, SL na breakeven, DCA otkazani
4. `CLOSING` ‚Üí zadnji TP/SL se izvr≈°ava
5. `CLOSED` ‚Üí sve zatvoreno, PnL finalizovan
6. `CANCELLED` / `ERROR` ‚Üí ako ne≈°to poƒëe po zlu

---

## üîî 5.10. Event sistem (events.js)

Standardizuj event-e da mo≈æe≈° lako da loguje≈° i prika≈æe≈° na dashboard-u:

* `position_opened`
* `tp_hit` (index 1/2/3)
* `dca_executed` (index 1/2/3)
* `breakeven_activated`
* `position_closed`
* `position_error`

Svaki event ima payload:

```ts
{
  positionId,
  symbol,
  side,
  index?,       // za TP/DCA
  price,
  qty,
  pnl?,
  roi?,
  timestamp
}
```

---

## üß™ 5.11. Test scenariji FAZE 5

**Mora≈° pripremiti simulacione testove** (fake price feed + fake order executor):

1. **Idealni trade bez DCA**

   * Entry @ 1.0000, SHORT
   * Cena padne 0.84% ‚Üí TP1 hit ‚Üí 40% zatvoreno, SL na BE
   * Cena padne 1.64% ‚Üí TP2
   * Cena padne 4% ‚Üí TP3
   * Proveri PnL, levels, state = CLOSED

2. **Trade sa DCA1, pa FULL recovery** (PIXEL scenario)

   * Cena prvo ide protiv 5‚Äì7% ‚Üí DCA1
   * Nema SL, avgEntry se pomera
   * Onda cena ide u na≈° smer ‚Üí TP1/2/3
   * Potvrdi da trade zavr≈°ava u debelom plusu

3. **Trade gde TP1 hit, ali se vrati na breakeven**

   * TP1 se pogodi ‚Üí breakeven aktiviran, DCA otkazani
   * Cena se okrene i pogodi SL na BE
   * Finalni PnL ~ 0 (mali plus ili minus od fee)

4. **Trade gde DCA2 ili DCA3 aktivni**

   * Testiraj rekalkulaciju avgEntry i TPs vi≈°e puta

5. **Simulacija bug situacija**

   * Partial fill, half TP triggered, WS drop
   * Restart sistema ‚Äì da li uƒçitava state i nastavlja?

---

## ‚úÖ 5.12. FAZA 5 ‚Äì checklist

* [ ] `Position` model definisan
* [ ] `positionManager` sa `openPosition()` i interfejsima
* [ ] `tpEngine` implementiran (setup + check)
* [ ] `dcaEngine` implementiran (setup + check + avgEntry)
* [ ] `slEngine` (breakeven) ‚Äì SL posle TP1 + cancel DCA
* [ ] `priceWatcher` ‚Äì hook na market feed
* [ ] `pnlCalculator` ‚Äì ROI i PnL taƒçni
* [ ] Event sistem i logging
* [ ] Sim testovi za 4‚Äì5 scenarija iznad

---

Ako ≈æeli≈°, sledeƒái korak mo≈æe biti:

* da FAZU 5 dodatno ‚Äúprelomimo‚Äù u **konkretan kod skeleton** (fajlovi sa export funkcijama i TODO blokovima), spremno da iskopira≈° u `src/position/`
  **ili**
* da krenemo FAZA 6 ‚Äì **State Machine & Orkestracija** (kako sve faze 1‚Äì5 rade zajedno za jedan trade).
