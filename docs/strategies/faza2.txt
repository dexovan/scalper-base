Razumem, idemo ƒçisto *tvoj sopstveni sistem*, bez Discorda, samo na≈° engine na tvom serveru u Singapuru. üí™
Sada radim **FAZA 2 ‚Äì MACRO FILTERS** kao **poseban, ultra-detaljan programersko-tehniƒçki dokument**, u istom stilu kao FAZA 1.

---

# FAZA 2 ‚Äì MACRO FILTERS (Market Environment Engine)

**Cilj faze:**
Napraviti **samostalan modul** koji periodiƒçno povlaƒçi makro-podatke sa interneta (VIX, Fear & Greed, Altseason Index, BTC dominacija, ukupne likvidacije, BTC 24h promenu‚Ä¶) i pretvara ih u **jedan normalizovan ‚Äúmacro_score‚Äù** i set flagova koje na≈° signal engine koristi:

* da li **uop≈°te sme da trguje danas** (kill switch),
* da li da bude **agresivan / normalan / defanzivan**,
* da li da **ograniƒçi broj trejdova, leverage, size‚Ä¶**

Ova faza **ne donosi odluke o entry-ju za pojedinaƒçni coin**, veƒá odreƒëuje **‚Äúvremensku prognozu‚Äù tr≈æi≈°ta** za ceo dan.

---

## 2.0. Arhitektura & Integracija

### 2.0.1. Fajlovi / Modul

Predlog strukture (ESM, kao ≈°to veƒá koristi≈°):

```text
src/
  macro/
    macroEngine.js          # Glavni modul - orchestration
    providers/
      vixProvider.js        # VIX index
      altseasonProvider.js  # Altseason index + BTC dominance
      fearGreedProvider.js  # Fear & Greed index
      liquidationsProvider.js # 24h liquidations (crypto)
      btcContextProvider.js # BTC price & direction info
    cache/
      macroCache.json       # Disk cache (za fallback)
```

### 2.0.2. Public API (prema ostatku sistema)

`macroEngine.js` izla≈æe:

```js
// async, jer zove HTTP providere
export async function getMacroContext() {
  return {
    timestamp,           // ISO string
    score,               // 0‚Äì100 macro_score
    regime,              // 'BLOCKED' | 'DEFENSIVE' | 'NORMAL' | 'AGGRESSIVE'
    positionMultiplier,  // npr. 0.0, 0.5, 1.0, 1.5
    maxDailyTrades,      // npr. 4, 7, 10
    reasonFlags: {       // flagovi koji obja≈°njavaju ZA≈†TO
      vix: {...},
      altseason: {...},
      fearGreed: {...},
      liquidations: {...},
      btcContext: {...}
    }
  };
}
```

U FAZA 3 / FAZA 4, tvoj **signal engine** ƒáe zvati:

```js
const macro = await getMacroContext();

if (macro.regime === 'BLOCKED') {
  // skip sve signale, log reason
}

if (macro.regime === 'DEFENSIVE') {
  // smanji position size, poo≈°tri entry threshold itd.
}
```

---

## 2.1. Konfiguracija (config/macro.json)

Napravimo jedan **centralni config fajl** (ili deo u `config.js`) za pragove:

```js
export const MACRO_CONFIG = {
  refreshIntervalSec: 300, // 5 min

  vix: {
    panic: 30,
    elevated: 25,
    calm: 20
  },

  altseason: {
    altSeasonActive: 75,
    btcSeason: 50
  },

  fearGreed: {
    extremeGreed: 85,
    healthyGreedMin: 60,
    healthyGreedMax: 80,
    fear: 45
  },

  liquidations: {
    extreme: 500, // M$
    high: 200,
    low: 100
  },

  btc: {
    strongMove: 3,  // ¬±3% 24h
    flat: 1         // <1%
  },

  scoringWeights: {
    // ukupno neka budu ~100
    vix: 30,
    altseason: 20,
    fearGreed: 15,
    liquidations: 10,
    btc: 5,
    base: 20 // start baseline 20/100
  }
};
```

---

## 2.2. VIX Provider (vixProvider.js)

### 2.2.1. Zadatak

* Povuci vrednost **VIX indeksa** jednom na npr. 15 minuta.
* Mapiraj u:

  * `status`: `"CALM" | "NORMAL" | "ELEVATED" | "PANIC"`
  * `killSwitch`: `true/false`
  * `positionMultiplier`: npr. 1.0, 0.5, 0.0
  * `scoreContribution`: broj poena za macro_score.

### 2.2.2. Interface

```js
export async function getVixContext() {
  return {
    raw: {
      value: 18.34,  // broj
      source: 'someApiName'
    },
    status: 'NORMAL',
    killSwitch: false,
    positionMultiplier: 1.0,
    scoreContribution: 25, // 0‚Äì30 u skladu sa weight
    note: 'VIX normal, full size allowed'
  };
}
```

### 2.2.3. Logika mapiranja

* Ako `vix >= panic` (30):

  ```txt
  status = 'PANIC'
  killSwitch = true
  positionMultiplier = 0.0
  scoreContribution = 0
  note = 'Market panic, trading disabled'
  ```

* Ako `25 <= vix < 30`:

  ```txt
  status = 'ELEVATED'
  killSwitch = false
  positionMultiplier = 0.5
  scoreContribution = ~10
  note = 'Elevated fear, use half size'
  ```

* Ako `vix < calm` (20):

  ```txt
  status = 'CALM'
  killSwitch = false
  positionMultiplier = 1.0
  scoreContribution = maxWeight (npr. 30)
  note = 'Calm volatility, ideal environment'
  ```

* Ostalo (20‚Äì25):

  ```txt
  status = 'NORMAL'
  killSwitch = false
  positionMultiplier = 1.0
  scoreContribution = ~20
  ```

### 2.2.4. Tehniƒçki detalji

* Unutar providera:

  * `fetchVix()` ‚Üí HTTP GET ka nekom public API-ju (u implementaciji ƒáemo precizirati endpoint).
  * Cache u memoriji (`lastValue`, `lastUpdated`).
  * Ako poziv doƒëe pre isteka `refreshIntervalSec` ‚Üí vrati cached.

* Fallback:

  * Ako API failuje:

    * ako imamo stari cache < 24h ‚Üí vrati njega + `note: 'stale data'`.
    * ako nemamo ni≈°ta ‚Üí `status: 'UNKNOWN'`, `killSwitch: false`, `scoreContribution: MACRO_CONFIG.scoringWeights.vix / 2` (neutral), i `note: 'VIX unavailable, neutral weight'`.

---

## 2.3. Altseason Provider (altseasonProvider.js)

### 2.3.1. Zadatak

* Povuci **Altseason Index** (0‚Äì100).
* Povuci **BTC dominance** (procenat).
* Odredi:

  * da li je **ALTSEASON** (kapital ide u altove),
  * da li je **BTC season** (dominacija BTC, altovi slabi),
  * na osnovu toga: coin universe re≈æim (samo BTC ili BTC+alts).

### 2.3.2. Interface

```js
export async function getAltseasonContext() {
  return {
    raw: {
      altIndex: 78,       // 0‚Äì100
      btcDominance: 56.7, // %
      source: 'someApi'
    },
    mode: 'ALTSEASON' | 'MIXED' | 'BTC_SEASON',
    allowedUniverses: ['LOW_CAP_ALTS', 'BTC'], // ≈°ta na≈° engine mo≈æe koristiti
    scoreContribution: 0‚Äì20,
    note: 'Altseason active, aggressive alt trading enabled'
  };
}
```

### 2.3.3. Logika

* Ako `altIndex >= altSeasonActive` (75):

  ```txt
  mode = 'ALTSEASON'
  allowedUniverses = ['LOW_CAP_ALTS', 'BTC']
  scoreContribution ‚âà maxWeight (20)
  ```

* Ako `altIndex < btcSeason` (50):

  ```txt
  mode = 'BTC_SEASON'
  allowedUniverses = ['BTC']  // zabranimo altove
  scoreContribution ‚âà 5‚Äì10
  note = 'BTC dominant, altcoin signals heavily filtered'
  ```

* Ostalo:

  ```txt
  mode = 'MIXED'
  allowedUniverses = ['LOW_CAP_ALTS', 'BTC'] ali sa manjim score
  scoreContribution ‚âà 10‚Äì15
  ```

---

## 2.4. Fear & Greed Provider (fearGreedProvider.js)

### 2.4.1. Zadatak

* Povuci **Crypto Fear & Greed Index** (0‚Äì100).
* Odredi:

  * `marketState`: `"EXTREME_FEAR" | "FEAR" | "NEUTRAL" | "HEALTHY_GREED" | "EXTREME_GREED"`
  * `confidenceAdjustment`: npr. `-0.15`, `+0.05` itd.
  * `scoreContribution`.

### 2.4.2. Interface

```js
export async function getFearGreedContext() {
  return {
    raw: {
      value: 71,
      source: 'alternativeMeOrSimilar'
    },
    marketState: 'HEALTHY_GREED',
    confidenceAdjustment: +0.05,
    scoreContribution: 0‚Äì15,
    note: 'Healthy greed 60‚Äì80, ideal scalping environment'
  };
}
```

### 2.4.3. Logika

* `fg > extremeGreed (85)`:

  ```txt
  marketState = 'EXTREME_GREED'
  confidenceAdjustment = -0.1
  scoreContribution ‚âà 5‚Äì8
  note: 'Euphoria - tops form here, be cautious'
  ```

* `60 <= fg <= 80` ‚Üí Andre sweet spot:

  ```txt
  marketState = 'HEALTHY_GREED'
  confidenceAdjustment = +0.05
  scoreContribution ‚âà 12‚Äì15
  ```

* `45 <= fg < 60`:

  ```txt
  marketState = 'NEUTRAL'
  confidenceAdjustment = 0
  scoreContribution ‚âà 8‚Äì10
  ```

* `< 45`:

  ```txt
  marketState = 'FEAR'
  confidenceAdjustment = -0.15
  scoreContribution ‚âà 5‚Äì8
  ```

---

## 2.5. Liquidations Provider (liquidationsProvider.js)

### 2.5.1. Zadatak

* Povuci **24h globalne likvidacije** na kriptomarketima (USDT vrednost).

* Klasifikacija:

  * `EXTREME`: > 500M
  * `HIGH`: 200‚Äì500M
  * `NORMAL`: 100‚Äì200M
  * `LOW`: < 100M

* Uticaj:

  * `HIGH` = dobro za scalping.
  * `LOW` = tr≈æi≈°te ‚Äúmrtvo‚Äù, choppy.

### 2.5.2. Interface

```js
export async function getLiquidationsContext() {
  return {
    raw: {
      total24h: 342, // M$
      source: 'coinglassOrSimilar'
    },
    volatility: 'HIGH' | 'NORMAL' | 'LOW' | 'EXTREME',
    scoreContribution: 0‚Äì10,
    note: 'High volatility, good for fast scalps'
  };
}
```

### 2.5.3. Logika

* `> extreme (500)`:

  ```txt
  volatility = 'EXTREME'
  scoreContribution = 5‚Äì7
  note = 'Extreme cascade, maybe temporary pause / extra caution'
  ```

* `> high (200)`:

  ```txt
  volatility = 'HIGH'
  scoreContribution = 10
  note = 'Great environment, lots of moves'
  ```

* `< low (100)`:

  ```txt
  volatility = 'LOW'
  scoreContribution = 3‚Äì5
  note = 'Low vol, expect chop'
  ```

* Ostalo ‚Üí `NORMAL` (7‚Äì8).

---

## 2.6. BTC Context Provider (btcContextProvider.js)

### 2.6.1. Zadatak

* Povuci BTC:

  * 24h % promenu,
  * mo≈æda 4h / 1h promenu,
  * eventualno korelaciju sa alts.

* Odluƒçi:

  * da li favorizujemo LONG/SHORT,
  * da li je `flat` i time **smanjujemo confidence**.

### 2.6.2. Interface

```js
export async function getBtcContext() {
  return {
    raw: {
      change24h: -3.4, // %
      price: 95576.3,
      source: 'bybitOrCexOrCoingecko'
    },
    alignment: 'LONG' | 'SHORT' | 'NEUTRAL',
    scoreContribution: 0‚Äì5,
    note: 'BTC -3.4% 24h, short bias for alts'
  };
}
```

### 2.6.3. Logika

* `change24h > strongMove (3%)`:

  * Ako je alert LONG ‚Üí `alignment = 'LONG'`, `scoreContribution = 5`.
  * Ako je alert SHORT ‚Üí penalizuj (‚àí2 ili 0).

* `change24h < -strongMove (-3%)`:

  * Obrnuto ‚Äì ako alert SHORT ‚Üí +5, ako LONG ‚Üí -.

* `abs(change24h) < flat (1%)`:

  ```txt
  alignment = 'NEUTRAL'
  scoreContribution ‚âà 2‚Äì3
  note = 'BTC flat, alt environment mixed'
  ```

*Napomena:* BTC context realno ima mali weight (5), vi≈°e kao fine-tuning.

---

## 2.7. Macro Engine ‚Äì Orchestration (macroEngine.js)

### 2.7.1. Zadatak

* **Jedan centralni servis** koji:

  1. Povlaƒçi sve providere paralelno.
  2. Kombinuje njihove score-ove u `macro_score` (0‚Äì100).
  3. Zadaje `regime` i `positionMultiplier`.
  4. Radi **caching** i throttling.

### 2.7.2. Data model

```js
// tip koji vraƒáa getMacroContext()
{
  timestamp: '2025-11-22T13:45:00Z',
  score: 78,                       // 0‚Äì100
  regime: 'NORMAL',                // ili BLOCKED/DEFENSIVE/AGGRESSIVE
  positionMultiplier: 1.0,         // 0‚Äì1.5
  maxDailyTrades: 7,
  reasonFlags: {
    vix: { status, killSwitch, ... },
    altseason: { mode, ... },
    fearGreed: { marketState, ... },
    liquidations: { volatility, ... },
    btc: { alignment, ... }
  }
}
```

### 2.7.3. Regime logika

Na osnovu `score` + `killSwitch`:

```txt
if any killSwitch === true ‚Üí regime = 'BLOCKED', score = 0, positionMultiplier = 0.0

else:
  if score < 40 ‚Üí regime = 'DEFENSIVE', positionMultiplier = 0.5, maxDailyTrades = 3‚Äì4
  if 40 <= score < 70 ‚Üí regime = 'NORMAL', positionMultiplier = 1.0, maxDailyTrades = 5‚Äì7
  if score >= 70 ‚Üí regime = 'AGGRESSIVE', positionMultiplier = 1.2‚Äì1.5, maxDailyTrades = 7‚Äì10
```

Score raƒçunanje:

```js
const base = weights.base; // npr. 20

score =
  base +
  vix.scoreContribution +
  altseason.scoreContribution +
  fearGreed.scoreContribution +
  liquidations.scoreContribution +
  btc.scoreContribution;

score = Math.max(0, Math.min(100, score));
```

### 2.7.4. Caching & Refresh

* `macroEngine` internu dr≈æi:

```js
let lastMacroContext = null;
let lastUpdated = 0;
const REFRESH_MS = MACRO_CONFIG.refreshIntervalSec * 1000;
```

* `getMacroContext()`:

```js
export async function getMacroContext() {
  const now = Date.now();

  if (lastMacroContext && (now - lastUpdated) < REFRESH_MS) {
    return lastMacroContext; // koristi cache
  }

  // inaƒçe ‚Äì fetch svi provideri paralelno
  const [vix, altseason, fg, liq, btc] = await Promise.all([
    getVixContext(),
    getAltseasonContext(),
    getFearGreedContext(),
    getLiquidationsContext(),
    getBtcContext()
  ]);

  // izraƒçunaj score + regime...
  const macro = computeMacro(vix, altseason, fg, liq, btc);

  lastMacroContext = macro;
  lastUpdated = now;

  // upi≈°i u macroCache.json za fallback posle restarta
  await writeMacroCache(macro);

  return macro;
}
```

* Na startu engine-a:

```js
lastMacroContext = await readMacroCache() || null;
```

Ako niƒçega nema, mo≈æe≈° vratiti **neutral default**:

```js
{
  score: 60,
  regime: 'NORMAL',
  positionMultiplier: 1.0,
  maxDailyTrades: 5,
  reasonFlags: { all: 'UNAVAILABLE_FALLBACK' }
}
```

---

## 2.8. Error Handling & Fallback Strategija

Za svaki provider:

* Ako HTTP fail, timeout, invalid JSON:

  * log: `logger.warn('[macro] VIX provider failed', error)`
  * return `status: 'UNKNOWN'`, `scoreContribution: weight/2`, `note: 'API error, neutral assumption'`.

Za engine:

* Ako veƒáina providera failuje (npr. 3/5 `UNKNOWN`):

  * postavi `regime: 'DEFENSIVE'`,
  * `positionMultiplier = 0.5`,
  * `maxDailyTrades = 3`,
  * note: ‚ÄúMacro data unreliable, defensive regime‚Äù.

---

## 2.9. Testiranje (FAZA 2)

### 2.9.1. Unit testovi po provideru

Za svaki provider (mo≈æe≈° koristiti `jest` ili veƒá ≈°to koristi≈°):

* Mock HTTP odgovore za tipiƒçne sluƒçajeve:

  * VIX: 18, 22, 27, 35
  * Altseason: 40, 60, 80
  * F&G: 30, 50, 70, 90
  * Liquidations: 80M, 250M, 600M
  * BTC: +4%, -4%, 0.5%

* Verifikuj:

  * `status`/`mode`/`marketState` ispravno,
  * `scoreContribution` unutar oƒçekivanog raspona,
  * `killSwitch` tamo gde treba.

### 2.9.2. Integration test za macroEngine

* Mock-uj providere sa unapred zadatim vrednostima, npr:

  #### Scenario 1 ‚Äì ‚ÄúPerfect day‚Äù (kao Oct 7‚Äì8):

  ```txt
  VIX=18 ‚Üí CALM, 30p
  AltseasonIndex=78 ‚Üí ALTSEASON, 20p
  F&G=71 ‚Üí HEALTHY_GREED, 15p
  Liquidations=428M ‚Üí HIGH, 10p
  BTC change=+1.1% ‚Üí NEUTRAL, 3p
  base=20

  score=20+30+20+15+10+3=98 ‚Üí regime='AGGRESSIVE'
  ```

* Proveri da:

  * `regime === 'AGGRESSIVE'`
  * `positionMultiplier ~ 1.2‚Äì1.5`
  * `maxDailyTrades ~ 8‚Äì10`.

* Scenario 2 ‚Äì panic:

  ```txt
  VIX=35 (PANIC, killSwitch)
  ```

* Oƒçekivanje:

  * `regime='BLOCKED'`,
  * `positionMultiplier=0`,
  * `score=0`.

* Scenario 3 ‚Äì mixed:

  Kombinacija koja daje score ~50 ‚Üí `NORMAL`.

---

## 2.10. Integracija sa sledeƒáim fazama

FAZA 2 output koristi se:

* u **FAZA 3 (Peak detection & entry timing)**:

  * `macroContext.positionMultiplier` ‚Üí utiƒçe na **position size**.
  * `macroContext.regime` ‚Üí mo≈æe podiƒái minimalni entry score sa 70 na 80 u DEFENSIVE modu.

* u **FAZA 4 (Skip filters)**:

  * Ako `regime === 'BLOCKED'` ‚Üí `shouldSkipSignal()` odmah vraƒáa `skip=true` sa razlogom "Macro kill switch".
  * Ako `regime === 'DEFENSIVE'` ‚Üí max concurrent positions = 1‚Äì2 umesto 3.

---

## 2.11. Zavr≈°ni checklist za FAZA 2

**Kada ka≈æe≈° da je FAZA 2 gotova, ovo mora da va≈æi:**

* [ ] `src/macro/macroEngine.js` postoji i ima `getMacroContext()`.
* [ ] Svi provideri (`vixProvider`, `altseasonProvider`, `fearGreedProvider`, `liquidationsProvider`, `btcContextProvider`) rade sa mock/test API-jem.
* [ ] `MACRO_CONFIG` centralizovan u jednom fajlu.
* [ ] Disk cache (`macroCache.json`) se upisuje i ƒçita.
* [ ] Unit testovi pokrivaju bar *po 3 scenarija* po provideru.
* [ ] Integration test pokazuje 3 glavna scenarija: `AGGRESSIVE`, `NORMAL`, `BLOCKED`.
* [ ] Engine loguje **razlog** za svaki regime (`reasonFlags`).

---

Ako ti ovakav nivo detalja odgovara, sledeƒái korak posle FAZA 2 dokumenta je:

* ili **FAZA 3 ‚Äì Peak Detection & Entry Timing (mikro-level)**
* ili **FAZA 4 ‚Äì Skip Filters & Trade/day logic**

Ti samo reci ‚ÄúKreni FAZA 3 specifikacija‚Äù i odma radim isto ovako detaljno za entry timing.
